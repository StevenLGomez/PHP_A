
Introduction

Welcome

Welcome to PHP with MySQL essential training part one. My name is Kevin Skoglund. In this course, we will learn to use PHP to create, read, update and delete records in a MySQL database. We will discover how to effectively organize the PHP pages in a project. We will build web pages in PHP that can send and read parameters in the URL. We will learn about headers, redirects, and the importance of output buffering. We will learn to create forms and to process form data. We will cover the basics of MySQL, use PHP to communicate with the database, and learn to perform the most common database operations.

And finally, we will learn how to validate and sanitize dynamic data to keep your application and its data in good shape. Once you're ready, let's get started learning to use PHP with MySQL.

How to use the Exercise Files

This course includes exercise files. In order to make use of those files, you'll want to first make sure that you have PHP and MySQL installed and working. The exercise files are arranged by chapter, and by movie. And you can find the exercise files that correspond to the movie that you're watching by first looking for the chapter number, and then the movie number. You should copy the exercise files into your web document route directory. That's the location where your web server will look for files when a browser requests them. On my Mac, that will be inside my User directory, inside the Sites directory.

It's always a good idea to make a copy of the exercise files so that you'll still have the original to refer back to if you make changes. I'm going to opt + drag the folder to create a new copy. Beginning in chapter five, we'll be incorporating a database into our project, and for the exercise files to work, your database needs to match what the files expect. In the exercise files for these chapters, you will find a database file that you can load into MySQL to put your database into the same state as mine. If you don't already have a database, the first few movies of chapter five will get you started.

You can load that file directly into a MySQL database, either by using a tool such as phpMyAdmin, or by going to a command line program, and typing, mysql, then a space, -u, and then a space, and then a username that's authorized to access the database, and then, -p. Follow that with the database name that you want to import into, and then a less than sign, and finally, the path to the exercise file. If you're on a Mac, you may be able to just drag that file into the window, in order to get the full path to that file.

When we finally hit Return, it'll prompt you for a password, and you enter the password for the user that you specified. And then the data will be imported. Note that the import will remove all old database data at the same time as it imports new data. Importing can also be useful if you do a lot of experimenting on your own, but then want to get your data back in sync with mine. Once you have the same files in the same database, you'll be able to follow along with me. Everything that's in the exercise files, we will create together during the tutorials.

So you can just work along with me, and your files will mirror what's in the exercise files. Remember, that you can pause the video, or rewind if you need more time to copy something down. You can also use the exercise files to check your work, or to get back in sync, if you experiment on your own.

1. Start a Database Driven Project

1.1 Blueprint the Application

We will begin creating our database driven project by learning how to blueprint an application. The web application that we're going to be building is a Content Management System. Or CMS, for short. The idea is to have private webpages which administrators can use to create and edit website content. But the public has different pages where they can read the content but which are not editable. An essential first step when beginning any web project is to create a project blueprint. If the site is simple, you may be able to simply type up a few notes or draw a picture on a single piece of paper.

If your site's complex, you may need page mock-ups and flowcharts to keep track of everything. The fundamental idea, in either case, is to take what's in your head and to put it on paper. So that you can look it over and assess it before you start your work. It helps you to clarify the work that's ahead. And forces you to think about problems that you might otherwise have put off until you were well down the road with your development. I usually do my blueprinting by getting out pen and paper and drawing boxes to represent different parts of the site. I draw connections between the boxes and I make notes and details that I don't want to forget.

By the end, I have the full picture in front of me. And I don't have to hold all the moving parts in my head anymore. Instead, I can use that part of my brain for development. I also don't have to try and build the whole site all at once. I can begin to tackle it piece by piece. Moving through it in a methodical fashion. I can also tack my blueprint up on the wall in front of me. So that I can refer to it constantly as I'm developing. It's efficient and it's liberating. So let's begin our blueprint for our Content Management System.

We know that we're going to need to have two areas. The Public Area and the Admin Area. The Public Area is going to be fairly simple. The pages are all going to have a similar page structure. An area for navigation, like a menu of content, and then an area to view that page content. So users will pick a navigation item and then the PHP page that loads will show that pages content. Pick a new navigation item, get new page content. For the Admin Area, I know that I'm going to need to start with a login page. Where we can ask admin users to provide a user name and password to authenticate themselves and gain access.

That'll keep the public out. If they log in successfully, then we'll take them to an admin menu page. This is a simple landing page that lists the options in the admin area. Those options are just links to those other pages. The menu choices will be manage content, manage admins, and logout. In the manage content area, I want to divide our website content into two parts. Subjects and pages. So the webpage content will be stored on pages but then those pages are going to be grouped by their subject.

We'll see an example of this in just a moment. Next, we'll need a section to maintain the admin users. That is the users who can access this admin area and use the CMS to update content. And, of course, the final menu option is going to be, simply, logout. Which will perform that action of logging us out of the admin area. In this course, which is part one of a two part series, we're going to focus on building the Admin Area section that allows us to manage page content. Our subjects and our pages. This is going to give us an opportunity to learn how to interact with the database and to create new records, read existing records in the database, edit those records and delete records.

Then, in part two of this course, we'll build on those fundamentals of database interaction to complete our Content Management System. So that completes the blueprint of our application architecture. Let me show you some examples so that you'll have a better idea of where we're headed. This is what the public facing version of our website is going to look like. At the moment, these are just simple HTML pages. You can see that we have the name of our fictitious website, Globe Bank International, up at the top. And then we have a navigation over here that allows us to select different subjects that we might want to view the content for.

We also get a default homepage that's here. If we click About Globe Bank, you'll see that it loads up the About Globe Bank page. This is a page content below the subject. We also have History, Leadership, Contact Us, and so on. And each one of these subjects has different pages that are listed underneath it. So, again, this is our navigation. This is our page content area. So that's what we're going to be building on the public side, eventually. What we're going to be building in this course is going to be the Content Management System portion that'll allow us to manage this page content.

Here's an example of what that might look like. So here's an example of the Staff Area that we're going to be building in this course. Now there is no login or logout at the moment. We don't have any admin users, there's no passwords or anything like that. We're going to be building all of that in part two. We'll learn about user authentication. We'll learn how to password protect all this content. For this course, we're going to be focused exclusively on how we interact with the database. So that we can manage the content of our subjects and our pages. So let's click on Subjects to get an idea of what that looks like.

When I click on Subjects, you'll see I get a list of the subjects that are in the database. Notice this is PHP, it is pulling content from the database. And I'm getting a list of all the subjects that are currently in the database. It's reading those back and displaying them. Then I also have the ability to view detail on any one of those. I'll click View. And you can see I get a detailed view about what's in each one of those records. I also have options for editing. Or, I'll go back, I have an option for deleting. If I want to delete the content.

There's also an option up here for creating a new subject. If I want to add a new subject to the database as well. So those are the basic ways we're going to interact with this content. We're going to do it for both subjects and, also, for our page content. Now that we have an overall understanding of what we're going to be creating, let's get started by creating the beginnings of our project.

1.2 Establish Your Work Area

Now that we have a blueprint for our application, let's begin creating the project files that we're going to need. I use a standard structure for all of my php projects and it looks something like this. I have the main project directory, here I've just called it basic_php_project/, but I would rename it to be whatever the project name was. But then, inside of there, I've got two subdirectories, or folders. One is called public/ and one is called private/. The idea is that we configure our web server to serve content from the public directory.

In other words, public/ becomes our web document route. If our website was called coolsite.com, then a request for coolsite.com would come to our web server and our web server would look for files in this public directory. Therefore, everything in public/ is public. This is the place where we'd put all of the webpages that a user ought to be able to see, as well as images, style sheets, java scripts, or any other media or assets that our website needs to function. Those are all the things that the public should be able to get their hands on.

In our private/ directory; however, we can put content that should not be accessible by the public. There's no way for a request for coolsite.com to be sent, via the web server, to that private/ directory. So this is a place then, we can put libraries of php code and the public won't be able to access it directly; however, the php files that are in the public directory, can still access that code stored in the private/ directory because they have access via the file system. That is, they can navigate the hard drive structure in order to load those files.

We'll see how to do that later in this chapter and we'll also talk about the roles of initialize.php and functions.php when we do. For now, notice also that public/ has an index.php file already in place. It's a best practice to always have an index.php page in every single public directory that you create. The reason why, is that it's possible to have a web server which is configured to display the contents of the directory whenever an index.php page is not present, and that's probably not desirable.

That might give away information about some files that are present on our web server that we don't want the public to know. So, by putting that index.php page there, it prevents that web server behavior. So, let's start with that basic_php_project/, I'm going to open up my sites directory, this is my web document route, currently, for development, and I'm going to take my basic_php_project and I'm just going to drag it in there. And you can see that I've got all those files that we just talked about, they're in a different order now because they're being alphabetized, so you can see that I've got private here on top, with functions and initialize and shared; and I've got public with images, index.php, and stylesheets here.

So, now that we it in our sites directory, I'm just going to change the name of this and the name of our project is goin' to be globe_bank, so globe bank is going to be the name of the project that we're going to be working with. So now that we have the basic structure of our project in place, now let's talk about what we're going to be creating in this course. We're going to be working in the staff area. So, let's create a new directory. It's going to be inside the public directory because we want it to be publicly accessible. Now, it's going to be password protected, so that only certain people can get in there, but it still is accessible by someone via our web server so it goes in the public directory.

So public doesn't mean it's accessible by the general public, it just means that it's accessible by some of the public. So let's call that staff. and inside staff, we know that we want to have index.php declared. Now, this file doesn't actually do anything at the moment, if we actually open it up, you'll see that it just contains some basic html, just as a starter template for us. For now, we just want to make sure that we remember to have some place holder that's in there. Let's talk for a moment about the contents of this admin, or staff area, that we're creating.

We could create a flat staff area, where we have all of our php files for all the things that you can do inside that staff area just listed directly in that folder. So, for example, we might have page_edit, page_delete, page_list, page_new, page_show, subject_edit, subject_delete, subject_list, subject_new, subject_show. You can see each one is named with the resource that we're working with, either page or subject, at the beginning of it, and then a underscore followed by the action that we want to perform. That's a good way to keep ourselves organized and be able to have different pages that accomplish these different features of our website.

That's fine for a small website, but it doesn't scale really well if we start to have a much larger website. So I want to show you another idea, which is to group them into resource folders. You can see here, I have the same thing, but instead of pages_edit, I have a directory called pages_ and then a file called edit inside that directory. Now, inside my staff area, I'll have a folder called pages/ and a folder called subjects/ and I'll know that everything having to do with subjects is inside that subjects/ folder.

It really just helps you to stay organized. Notice also, that I've renamed list.php to be index.php and that's because we need an index.php file in each one of these directories anyway. So it's a convenient way to handle both of those at once. So this is what I'm going to be working with. Now, we're going to come back and create all of those php files later, but for now, let's go ahead and create pages/ and subjects/ for the directories that we're going to be working with. So back to my desktop here, I'm going to take the staff directory, which has index.php in it already, and I'm just going to option drag that to get a copy.

And I think I can do that, just drop it right in there. No, it came out here, but that's alright, I'll move it up here. Now I've got staff.index.php and I'm going to rename that as being subjects and then I'll just option drag that one, create a duplicate, and I'll call that one pages. You can also copy paste it. A number of different ways you create that file. But the overall idea is we want to have pages, we want to have subjects, and we want to make sure we create that default index.php just so we get in that good habit.

Okay, so now we have our basic project structure together. In the next movie, let's start working with the content of these pages.

1.3 Create and Style the First Page

In the previous movie, we created the starting structure of the files that we're going to need, the basics of our project. Now we want to bring those up in a text editor, so that we can work with them. For most text editors, you can simply drag the directory onto the icon for the text editor, in order to open up the entire project in a project view, all at once, I've already done that here. It works the same way whether you're using TextMate, or Sublime, or something else. The overall idea is that my project is now visible in one column, I can navigate the files that I want to edit, and I can edit them over in the window on the right.

Let's begin by opening up the index.php page. It's immediately inside the public directory. Inside this file, you'll see that I've included a very simple HTML5 template. Nothing special about this, it's just the beginning of an HTML5 document, that we could then serve up to the public. PHP pages are just HTML pages that have PHP embedded in them, so this makes sense, that we would have this as a starting point. Now let's think for a moment, index.php, inside the public directory, is going to be the root of our website.

That's because we're going to tell our web server that the document root that it should serve to the public is this public directory, so for example, if we had a globebank.com as our URL, then globebank.com would load up index.php as its default page. So I'm going to put in here for the title, just Globe Bank. And then in the body, for now, I'm going to put h1, Globe Bank: Coming Soon. Now we're going to come back and work on the public site later, for now, I just want to have a placeholder here that we can look at.

Let's save that file, and let's bring it up in our web browser, so we can see that it's working. At this point, you should have already installed PHP, and have it enabled for your web server. You'll also want to make sure that your web server, whichever one you choose to use, is running, and able to serve files when your browser requests them. If you need help with any of that, you can refer to the course on installing and setting up PHP with MySQL. I'm going to navigate to that project. Now for me, in development, my web document for development, is localhost, and then ~kevinskoglund.

Now yours may be different, you'll have to use whatever is your default, it might just simply be localhost on its own, or it might be something different. Change it to fit your needs, but that's going to be my document root. And from there, then I'll need to have my project, which is globe_bank, and then the public directory. That's how I'm going to navigate to that index.php page. Now when we launch this to the public, remember, the public's not going to type all that. The public's just going to type our URL, globebank.com, and it's going to go to this exact same spot, right here, to start with.

So all of that is just for development, that's why we're going to have that full root path in there while we're developing. And you see that I get Globe Bank: Coming Soon. So that's great, we now know that we're able to locate the correct file via our browser, and our web server was able to handle the fact that it was a PHP file, with no problem. All right, so now let's go back over to our project, and now, let's take a look at this staff page, staff/index.php. Now here, let's just change the title. Let's make it GBI, just the initials for Globe Bank International, and let's add in here, to our body, a little bit more, let's add a header tag, and let's do one for navigation.

Just mistyped that, there we go, and let's do one for footer. Okay, those are just some basic HTML5 tags. Inside the header, we'll put h1, and let's make this one just say, GBI Staff Area. That's indented a little too far, let's take one of those out. For the navigation, let's put in ul tags. We'll put in one li tag, which is going to be a link, a href="index.php", and, it's going to be Menu.

And then let's close our li tag, and close our ul tag. And then down here in the footer, let's put &copy; that'll be the HTML entity for the copyright symbol, 2017 Globe Bank. Okay, so we can save that file, and we should be able to bring this up in our browser. But before we do that, I'm just going to go ahead and add in our first bit of PHP code here. I'm just going to drop in, instead of 2017 for the date, we're going to go put in php echo date, capital Y.

That'll call the PHP date function, it'll return the current year. So now we've actually got our first bit of PHP code, and we're going to make sure that that is working correctly, as well. If not, you'll need to troubleshoot that, and make sure you've got PHP working. So let's go back now, now, in order to get to this page, it's in the public directory, and then, inside staff. Now we could type out index.php, but by default, it should render that index.php page. And sure enough, here it is, GBI Staff Area, and you see we've got Menu link, and the PHP code did load up correctly.

We did get the year's 2017. Now if you're watching this in the future, your year will be different, that's not a problem. Just make sure that you did, in fact, get a year there, and not an error saying the PHP code didn't render. Okay, so we've now got it working, but this is pretty ugly. What we need to do is introduce a style sheet, so that we can style this code, and to do that, I'm just going to hide these files for a moment, and I'm going to go here to this staff.css file. I've already got a style sheet written up, we'll take a look at it, but I'm going to drag it into my stylesheets directory of my project.

Then I can come in here, to my project again, and let's take a look at what's in there. So you can see, I've just got some basic styling. You can pause the movie if you want to copy this down, it's also included in the exercise files. So you go down here, you see we've got a header, header h1. I've got navigation, I've got some styling on the navigation ul and li elements. I've got content, which we're going to add in later. I've got in the footer, and then I've got some styles here that we're going to be using as we go on. I wanted to go ahead and add them now, so that we don't have to come back to them.

I'm styling some of the different elements that we're going to be using as we create forms, and create all the different parts of the website. So there we go, we've got our errors. So that's it, it's a pretty simple style sheet, altogether. Again, it's included in your exercise files. Now we need to tell our page that it's going to use that style sheet. So the way we do that is we come up here into the head of our index.php that's in the staff page, and we're going to add a link tag, with rel=stylesheet, and the media for that is going to be all.

Everyone should get this style sheet, href=, and I'm just go leave that blank for now, and then close out the rest of the tag. Okay, so now we need the path to the style sheet. So what is the path to this style sheet? If you've worked with HTML before, then you already know how you do this. You need to navigate backwards one directory, because we're in the staff directory now, and we need to go out of the staff directory, and then into the stylesheets directory to get to staff.css. So that means that we've got to go .., which means go backwards a directory to the parent directory, and then locate the stylesheets directory, and then staff.css.

Now this href is telling it to go backwards in the URL. This is a browser path, not a file path. Now they're very similar, because it also happens to be the file path, as well, but I just wanted to make that point. We're going to come back to it a couple of times. This is the browser path, it's telling the browser to back up one level, and then look for stylesheets, staff.css. So let's save it, and let's go back and try it, see if it worked out, let's reload our page. And there you go, now there's not a lot there at the moment, because I don't have my content element, I think that's the one that probably gives it the real meat.

Let's add that, div id="content". And there we go, save it, go back, and I think that should probably give it, yeah, a nice big chunk of space here, that we can fill in below. And then we've got one link on the page, which is Menu. If we click that, you can see it just brings us back to this same page, index.php. So for now, make sure that you're able to bring up pages in your browser, make sure that PHP works, so that you have a date at the bottom of the footer, and that you are able to access the style sheet, that you do have the ability to link to the staff style sheet.

1.4 Include and Require Files

One useful feature in PHP is the ability to include code from other files into a PHP page. It's an important feature because it helps us to stay organized, and to not repeat ourselves. For example, if we define a function that we want to use on one webpage of our site, and we need to use it again on another page, we don't want to copy and paste that a second time. That would mean that we now have two versions of the function, and if we find a bug or we make an improvement, we have to remember to update the code in more than one place. That leads to bugs and code that's hard to maintain.

It's much better if we can put that function in a single file, and then load it in to both PHP pages, so that they're using the same version of the function all the time. And remember, that's the main reason we create functions, is to have reusable code. The way that we can do this in PHP is by using the include function. So inside our PHP tags we use include, and then the file name that we want to include. Functions are probably the most common thing that we include, but they're not the only thing. In addition to having libraries of functions, we can also load in sections of our page, such as the header, the footer, the navigation of the sidebar.

This allows us to take those sections of the website and create reusable portions of them that can be loaded into different pages. And now that code is all self-contained in one area where it's easy to find, and easy to update. And the same thing is true for really any reusable section of code, whether it has HTML, PHP, JavaScript or something else. Maybe there's code that defines how a banner ad ought to display, or page analytics, or the way that we want to display images on the site. All those can be packaged up into reusable portions that then we can use include and require to load them in as needed.

Now include is not the only way we can do that. We can also use require, and then variations on those, include_once and require_once. Require works exactly like include does, except it raises an error if the file is not found and able to be loaded. So really you use require if the file is essential to the operation of the rest of the page. If we get to require and something goes wrong, the rest of the PHP code will simply not execute. Include doesn't do that.

Include_once and require_once work the same way as include and require, except that they also keep track in PHP when a file is loaded. And if you ask it to load that file again, it'll skip over it. For something like PHP functions, this is an important feature, because you don't want to define a function more than once. PHP will give you an error, it'll say, "Sorry, you've already defined that function before." But if we wanted to do something like include code to load up a web advertisement on a page in three different places, then we'd want to use include and require, because we do want it to load three different times.

Now in practice, many times all four of these will work the same. They'll load in the code that you asked it to. But it's still a good programming habit to try to use the correct one for the current circumstances. Let's try doing this inside our project. I'm going to go into initialize.php, you can see I've already got some PHP tags here, and what I want to do is I want to tell initialize.php that it should load up all the code that's in functions.php. Now at the moment, that's empty, there's nothing that's in there either. But that's a place where we would define a library of functions that we could use.

The idea is that initialize is going to take care of loading not only this functions.php file, but other libraries of code as well. For example, I might want to have another file that contains all of my login functions, once I have login ability to the staff area. Or when I have another set of functions that's dedicated just to working with forms, and how we output forms on a page. I can separate all those out into separate files, and then initialize will take care of loading all of them in for me.

Now we want to use require, because the functions are required for our site to work correctly, and we want to use once because we only want to load them one time. So require_once, functions.php. And that's going to load up that functions.php file. If I had other files I would list them right underneath here, and we will. Later we'll have for example, database functionality. We'll keep that in a separate file. Now the reason I want to have it all in initialize.php is because then, let's say this file, I want to come back over here to my staff area, and on this staff page, I want to tell it that it should load up the functions, but I don't want to have to tell it to load up the basic functions and my form functions and my database functions.

I want to tell it just to load up initialize. And if it loads up initialize, I'll know that I've got all the functions that I need, all loaded in the correct order, and all available to me. So I'm going to have one line here at the very top of my file, it's going to be PHP, and it's going to be require_once, and it's going to be initialize.php, and let's close my tags. Okay so right here at the top of the file I'm going to load in that initialize.php file, and it will take care of loading everything else that needs to be loaded, getting everything all set up for me so I'm good to go.

But this isn't going to work quite right. When I was over here and I used require_once, functions.php was sitting in the same directory as initialize, so it found it no problem. Here I've got to tell this how to find initialize.php, it's not in the same directory. What I have to do is navigate the file system to get into the private directory and locate it. And I do that by first going backwards one directory, from the staff directory into the public directory, and then going backwards one more directory into the globe_bank directory.

Now I'm in the root of my project, and I can go forward into the private directory. Dot dot means go backwards, it means the parent directory. Notice here we're navigating the file system, not the browser URL like we were down here. It's different from this version. So dot dot does the same thing, it has the same concept to it, but here we're working with a URL, here we're working with the file system. I also want to make one important footnote here which is that you should always use static strings inside include and require_once.

Don't use dynamic data, if you do you can create major security issues where users can potentially load up files on your computer that they should not have access to. So just use static strings in here to keep yourself safe. Alright let's save that file. Now we could put a function in here and then try it out on this page to make sure we have access to it. I'm not going to do that. You can try that on your own if you want. Instead, what I want us to do, is I want us to look at the part of this page here that we have, all the beginning, everything up to the navigation, is going to be the same on every single page of our staff area.

And the footer is also going to be the same on every single page of the staff area. So again, that's reusable code. Even though it's not PHP code, it's mostly HTML, it's still what we're going to be using over and over again. So this is a good candidate for code that should also be included and required. So what I'm going to do is I'm going to take that code and I'm just going to cut the top of it, everything above content, and inside shared, I'm going to create a new file in there, and I'm going to call that file staff_header.php.

I'm going to paste my code in there. So now, all that staff header is in there, and let's go back to this file, and let's grab the footer, I'm going to cut that, and let's go into shared, create a new file, footer.php. Let me just open those so you can see them, oops, not footer, sorry let me rename that. Should be staff_footer, there we go. And let's paste that in there. So now we've got our staff footer as well. Let's save that, now you'll see that our index.php page is really limited to just the content that's unique to that page.

All we need to do is add in our shared code, include, and I'm using include now because it's really not a show-stopper if we didn't get it. You could also use require, it would work exactly the same, but I'm going to use include and say that it should go backwards two directories, it should go into private, and then into shared, and get staff_header.php. I'll copy that line, let's come down here, do the same thing, but this time it's staff_footer.php.

And I'm just going to take away the indentation there. So now we've got our basic code, staff/index.php, let's load it up in our browser and see if it all worked correctly. And let's reload our page. And sure enough, it works exactly the same, reading the exact same code there. You can reload it, force reload it with option if you want to make sure that you're getting a new one, or actually modify the header and footer so you can verify that you did get the new one. But you can see now I'm loading up the functions that I need, I'm loading up the header, then I just have to define what's unique to this page, and then I have the standard footer at the bottom.

You can see how this keeps our code well organized, and gives us reusable parts. In the next movie, we'll talk more about this idea.

1.5 Make Page Assets Reusable

In the previous movie, we learned to use include and require. In this movie, we'll learn some additional techniques that can help you to use them better in your projects. So, the first thing I want to show you is how we can use variables in PHP to work with these included and required files. Specifically, I want to be able to set a page title on this page, $page_title and I'm going to set it equal to, let's just call it Staff menu. I'll make it capital, Menu. Okay, so I'm setting this variable, $page_title, what I want to show you is that that variable is available inside this file.

It's an exactly as if that PHP code were right in this spot. Right at line four, all of the content of staff_header right there. That means we have access to any variables that have been set. I just want to make sure that that's clear to you. So, here we go, let's put in a dash and let's do echo our assigned page title. Now, of course, we want to make sure that page title is set. So let's go up here to the very top, let's put in a bit of PHP which says, if it's not set, page_title, then page_title will be equal to, and let's have it just say Staff Area.

That'll make sure we have a default page title set. We won't have a problem when we get down here because either we'll have one that's been passed in, or we have a default that'll kick in. So let's try it out, let's see if that works. Let's save this, let's go back to index.php, make sure we save that page as well. Let's go to out browser, let's reload our page. Notice now it says GBI - Staff Menu. So that's the first thing I want to make sure I showed you is that variables are still available inside those included files. That can be useful to know. The second thing is, let's take all of this code from index.php, and I'm going to copy it, and let's go to subjects index.php, where I also just have a basic HTML5 template.

I'm going to just replace that. I'm going to remove everything that's there and paste in my new code instead. It's not the Staff Menu now, instead now we're looking at the list of subjects. So that's the page title, is Subjects. So it should be able to now use a different page title with the staff_header. So let's save this file, and let's go try it out. Let's go back to Firefox, and this time, it's going to be staff/subjects, and you could put the index.php after it if you wanted. Notice that I get a warning followed by a fatal error.

Require_once was not able to find the file that it was looking for. So the problem here is that now my index.php page is nested inside the subjects directory. So the path to initialize.php is not the same. Now I have to go backwards one more directory. And the same thing for finding the staff header. Dot dot, slash. And the footer, dot dot, slash. Have to go one level further back. Let's save it, let's go back, let's reload our page, and now you see that the page opens up.

So now the page loads as expected and we don't get errors anymore. Now you'll notice that our style sheet is broken. We're not getting the big blue header and footer that we would expect to get from our style sheet. We'll come back to that issue in a moment. For now, I instead want to just deal with the issue of these dot dots. This can be a little bit of a hassle to remember where you're nested. To remember whether you're nested one level deep or two levels deep. One good solution to work from that is to set up some constants that you can use to define the path to these files.

So what I'm going to do is I'm going to come over to initialize.php, and before we even get to our functions, I'm going to paste in some code here. Let's just indent that a bit. And what I'm doing is I'm defining several constants. I'm defining a constant called private path, and that's using the current file, __FILE__, all in caps, returns the current path to this file, that file being initialize.php, tells PHP, hey, find this file's location and get its directory.

So what's the directory? Well, it's the private directory, so that's what we're calling PRIVATE_PATH, that's the same thing as the private folder, here. So what is our project path? Well, that's one directory above that. So I ask for the directory name, and that says go backwards one, and that tells us globe_bank. So now I have my private path, my project path, my public path is going to be the project path plus public. And my shared path, where my footer and header live, is going to be the private path plus the shared directory. Now I have these constants defined in PHP that I can use the easily locate those files.

So let me show you how we could use those. Let's save this file, come back over to index.php, this is the main index page. Now, instead of having all of these, let's remove all of this, and let's add in SHARED_PATH in all caps, and concatenate that together with staff_header.php. See how that works? Just copy this, do the same thing here, we'll just remove everything except for that forward slash. See how much nicer that is? It says, find that shared path folder, that's where you're going to find this file.

So this is a handy tool for being able to locate directories. Now, again, this is file paths that we're working with. Now, you might think, well, what about this one? Can I use private path here? No, you can't. And the reason why is because initialize.php is where all of this is defined. So there's one place that we still have to use the dot dots to get everything located correctly. And that's here when we first require the initialize. After that, we have our constant setup that we can work with. So let's save this file, and now let's come back over here.

Let me just copy these, and let's go into our subjects. Now, my subjects, I can just take those same lines and paste them in there. See how nice that is? So now my shared path is always the same. I still have to have an extra dot dot here that I didn't have there, because I do have to load up that initialize.php as the very first thing. Let's try it one last time, make sure it's all working. Come here, we'll reload it, and you'll see it still works exactly the same. And if we take subjects out and go back to this other page, it works correctly here.

Now, the style sheets still are broken, and in the next chapter, we're going to talk about how we can do the same kind of idea when working with links and URLs so that we can address our style sheet problem.

2. Build Web pages with PHP

2.1 Links and URLs

In the previous chapter, we built a simple web page and learned how to create reusable page assets. In this chapter, we're going to work on building webpages using PHP. Let's begin by learning how to create links between pages. You should already know how to code a simple HTML link. We use a tags around the word that we want to link, and then we use the href attribute of the a tag to define where we want the link to go to, in this case, index.php. Now, the first thing you should know is that there's no such thing as a PHP link.

It's still an HTML link. We can use PHP in order to generate the link, but the output will still be a string that creates an HTML link. So, the second example is using PHP, but it's still creating an HTML link exactly like the first one. Notice that it's using the word echo to output the string index.php. echo is very important. We have to make sure that we actually output the content from PHP into the HTML in order to have it work. Let's start by adding a link to our project to the main menu page.

So, that's staff, index.php, and inside the content area here I'm just going to paste some HTML. It's just going to be the main menu div that I'm creating. And let me just indent this a bit. There we go. And I'm missing a final div here. Here we go, div. All right, so you see it has a div, id main-menu, has h2 tags that says Main Menu, and then I've got ul tags that will just be a list of all the different things that we can do in the site. And you can see I've got an HTML link here for the subjects, right? So, that's going to link to the Subjects page, and the path to that page is inside the subjects directory, index.php.

Right, so let's save this file, and let's try it out. Let's save it. We'll come over here to Firefox. Let's reload our page. And sure enough, Main Menu, and it says Subjects. Okay, so let's click on the subjects link and see where it takes us. It came up with a page not found. Notice the URL that it went to right here, localhost/subjects/index.php. Now, if you are on a production server and the root of your website was the same as the domain, this would've worked fine, but it didn't work for us, because we're nested several layers deep here.

It's not localhost. It's localhost and then a bunch of directories after that. When we use this forward slash, it gives us an absolute URL, and that's not what we want. What we want is a relative URL. So, let's take that out, let's save the file, and let's go back. Let's reload the page, and now let's click subjects again, and now it takes us to the correct page, staff/subjects/index.php. That's where we wanted to be. So, it works because we used a relative path instead.

All right? So, now let's go up here. We've got that link there. Let's jump over to staff_header, and notice that I've got this link that says menu at the top of all my pages. The idea is that I have that menu link, and no matter where I am in the staff area, I could always click menu, and it'll just shoot me right back to that main menu so that I can navigate from there. So, right now it's index.php. We already know that we can use PHP there, and we can echo index.php, and it does the exact same thing, so let's try that.

Let's go back here. We'll load up the page. We'll reload our main menu, and if I click menu, it takes me where we would expect, takes me back to this same page, the page I'm already on. Let's click on subjects though, 'cause that's what we really want, is to be able to click menu on this page and shoot back to that other menu. So, let's click it. And it didn't work, and the reason it didn't work is not because we used PHP. The reason it didn't work is because it's a relative URL, and index.php is taking us back to the same page that it's already on, subjects, index.php.

What we really want is to tell it that it needs to go backwards a directory. It needs to go from relative from this page, we want to shoot backwards one. Let's save it. Let's go back over and go to Firefox, and let's reload this page. And now when I click menu, it takes me to the right page. Well, let's click menu again up here at the top of this page. Can you guess what's going to happen? Takes me back to my main home page. Why? Because I said relative to this page, go up one directory, right? We look back at our structure. It went from this index.php page back to this one.

That's not what we wanted. So, you can see that we have a problem here, and the problem is that we have a shared header file that we're using on multiple pages, and the links that we want to use, we want to use relative links, but they're relative to pages that are in different places. They're not in the same directory. Some of them are nested one level deeper, and they might even be nested several levels deeper. That's the exact same problem that we had with our stylesheets before. The the stylesheet works correctly when we're on our staff index.php page, but when we go to subjects, what we really need is ../../stylesheets/staff.css.

So, PHP enabled us to have this shared template, but now we've got a problem. How do we solve it? PHP can help us to do that. A good trick is to set a constant that defines the web root. Let me just jump over here to initialize.php, and we can define it here. Now, this is similar to what we did at the end of the last movie with SHARED_PATH. You see that right here. But it's not the same, because there we were talking about file paths on the hard drive. If you actually output SHARED_PATH and do echo on it on one of your pages, you'll see that's a path on your hard drive, from the root of your hard drive, all the way to the file that it's trying to find.

That's not what we want here. We want a path for the URL. So, we can do that a couple of different ways. I'm going to paste in some code. Some of it is instructions telling you you don't need to include the domain name. We want to use the same document root as the web server uses, and you can set a hard-coded value, like this. That would define WW_ROOT, and it would set it equal to my path, which is ~kevinskoglund/globe_bank/public. That's not the same for you. If you are on a production machine, you might define it as just being the root.

It's just simply whatever the domain name is. It's not nested anything deeper, or what I've got here, something that finds it dynamically. I'm doing it this way so that if you grab the code out of the exercise files, it'll work automatically for you in development. What it does is it looks for the presence of the word /public in the URL and figures out that that must be where the document root is. So, that's how it defines WWW_ROOT dynamically. And any of these would work. The main thing is to make sure that you set this value equal to an absolute value that we can then use on all our pages.

And once we have that set, now we can go back over to our staff_header and instead, we can use WWW_ROOT and append it with /staff/index.php. Now, I have to include the staff now, because WW_ROOT is the root of the entire website, not the staff area. I could also define another one of these called STAFF_ROOT if I wanted, but here I'm using WW_ROOT so that I can just use something generic. Let's try it, and let's see the difference.

Let's take this stylesheet back to what it was, save our file, come back over here, and we'll reload our page. And now when I click Menu, it's correct here. When I click Subjects, now it's correct there. Both of them work the same, and we can do the same thing for our stylesheets. Before we do that though, I want to show you that there's another nice trick, which is that we can actually roll all this up into a function that we can use. So, I'm going to define a function, I'm going to put it in functions.php, and I call it url_for, so url_for, and pass it in the path that you want.

It goes ahead and takes care of figuring out whether you have the leading forward slash or not. If it's not there, it adds it for you in case you forget, and then it appends it to that WW_ROOT and returns the value. It doesn't echo it. You still have to do the echoing, but it will calculate that value for you using that constant. All right, so let's save that. Now, we've got our function. Let's come back over here into our header, and let's use it. We're going to use it right here. php echo, we still need to echo, url_for, and then, in parentheses, let's just take stylesheets.

It doesn't matter whether we put the forward slash or not. And close our php tags. All right, let's do the same thing down here. We'll do url_for, and we'll just surround the whole thing in parentheses. Oops. Tapped one key too many. There we go. Okay. So, now that we've got that, let's try it out. Let's reload the page. It works correctly. Menu works correctly. Click on Subjects. Look at that. Our CSS is fixed now.

And menu works correctly. So, let's just review, why does all that work correctly? It's because we've defined an absolute point that we can base all of our other URLs off of. We've basically said here's the root of the website. Base everything off of that. So, now we have a single function that we can use which will make sure that we always have a URL that takes care of whether or not it's on a shared piece of code or whether it's something that's nested several layers deep. It'll always be a URL to the correct place.

It's a really handy tool to have.

2.2 Use URL Parameters

In this movie, we'll learn send a value from one page to the next by using URL parameters. This can also be referred to as query parameters. The URL parameters are the part of the URL which comes after the question mark. The format is always name of the parameter, then an equal sign and then the value of the parameter, so here we have page equals two. URL parameters generally modify the behavior of the code used for the response, so, in this example, the same PHP code would be run, but its behavior would probably be modified, so that it return the second page of results.

You can send more than one URL parameter by using an ampersand in-between them. Here you I have category equals seven and page equals three. If you surf around on sites like Google and Amazon, you'll see many examples of URL parameters being used. URL parameters are useful, because they allow us to pass data from one page to another via links. When a new page request is received, PHP is automatically going to take all of those URL parameters that were sent and put them into an associate of array where we can access them.

That array is what's called a Super global variable and the name for the one we're using here is going to be $_ and then capital GET and that makes sense, because get is the name of the HTTP method that relates to URLs and links. We'll learn more about get and post when we talk about forms. Notice that it has an underscore at the beginning and that it uses all capital letters. That's how all super globals are going to be named. There are about nine super globals altogether and we'll be looking at a few more later on.

Super globals are always available in all variable scopes. Basically, that just means that you have access to them from anywhere inside your code. That's not true for all variables and PHP is going to set those values for the super globals before our page of code even starts processing. They're available for us right at the start. Let's see how we can access them. In our PHP code, we would ask the super global get for its value for page and remember, it's an associative array, so we use the square bracket notation to access the array values, so here I'm asking the associative array that's stored in the super global get for the value that corresponds to page.

So, I'm retrieving that value and then I'm taking the variable page; a local variable and setting that value equal to it. This process of retrieving values from the super globals and assigning them to local variables is very common to have at the top of your PHP page. It's also important to note that the values that you retrieve from super globals are always going to be strings. Even if the value being set was a number like 99, the value that's retrieved is going to be a string containing the number 99; you'll need to change its PHP type to an integer if you want to use it as a number.

Here I've got a simple example; using get type, you can see that when we ask for get type of just the value that came straight out of get page, it's a string; if we typecast it using parenthesis int in front of it, that forces it to become an integer. Now, when we ask for its type, it's integer. So, just keep that in mind; the values are always strings no matter what. Let's try adding it to our project. Since the last movie, I've made a couple of changes to our project; let's take a look at what they are. The first it that on the staff many page.

I simply added in the url_for function that we wrote in the last movie, so now I'm using url_for here for my links to the subjects index page; otherwise, that's the same. Then, on the subjects index page, I've put quite a bit of code and this code is included in the exercise files and you can get it directly from there; there's no need to pause it and copy it down. Let's see what I've done here. The first thing is that I've got a variable called subjects and that variable contains an array and inside that array are four other arrays.

Each one of those arrays is a standing for record that would be in the database. We don't have a database yet; we are not working with databases until a little later on, but we're going to fake it here a bit. Database records work very much the same way. They work like arrays that have label bits of data. So, we have an ID, we have a position, we have visible and we have menu name and we have values for each of those stored in our database; here we just simply have arrays with that data hard-coded in. We'll come back and talk about this idea later on, but this just gives us a set of subjects that we can then display on our subjects listing page.

Let's scroll down and look at that listing. You can see at the top, I've got an h1 tag that just says subjects; I've got a link for create new subject; that link doesn't go anywhere yet, but it's a placeholder for it and then I've got a table and that table is a list of all the subjects that are going to be in my database later on. Right now, it's a list of all the subjects that are in my array. I have headers at the top that label each of the columns and then I'm looping through that array using foreach. So, foreach, one of the subjects in the array. I'm going to make each array called subject and now I can ask for the values inside that array for ID, position, visible and menu name.

I've also got placeholder links for view, edit and delete, but those don't go anywhere either. Let's go ahead and just bring this up, so that we can see what it looks like in our browser. Let's make sure we save it; let's go to Firefox (mumbles) start with my menu; I've got my subjects link. I click on that; it takes my into a Subjects page and now it's looping through that array in order to list out each one of these subjects. I've got About Glove Bank, Consumer, Small Business, etc. Now, this would be my listing of all the subjects that are in the database. What I want is to have a show page that will show me detail about just one subject.

So, when I send a link to go to that page, I need to tell it which one I want it to be. These four links have to all be different. One has to say: When you go to the next page, show me details about the subject about Globe Bank. This one should show me details about the subject called Consumer, so the way that we do that with databases is we use an ID to identify each record, so if I send along a URL parameter that includes the ID, then the next page will know which one I was referring to. It will be able to go to the database and retrieve that ID and bring back more information about it, so passing around these IDs is something that happens very frequently when we're doing web development, so let's edit this View link, so that it has that URL parameter in it.

Let's go right here; Let's start by just putting in echo url_for and I'm just going to leave that blank for a second, finish my PHP link and then let's come back here and let's think about what are url_for (mumbles) be. It's going to be /staff and then it's going to be subjects and then show.php; now, I've already created that page. It's in here, as well, but it's just blank. There is nothing in it at the moment. We'll come back to that in a moment. So, we need to think about what do we need to send after that; after it loads the page; what other parameter does it need to load properly? It needs to know the ID; question mark, ID equals and then we would want to provide the value.

The value could just be five, for example, but we want that to be dynamic. As we are looping through each of these subjects, we want it to change for each and everyone, so what I want to do is I want to use this value for the ID; copy that and I'm just going to use a period to concatenate it together, so ID equals and then whatever that value is. That'll build up a string and it'll create a different link for each one of these. Let's save it and try it out and let's reload our page. Now, when I click View; the second one down, you'll see it sends ID equals two.

At the back arrow; let's try the last one. Since ID equals four; so, now we're sending the correct query parameter; we're passing information from one page to the next; now, we just need to receive that information on the show page and we know how to do that; id equals underscore GET and then square brackets, id; that's going to get the value and assign it to our local variable and then let's just use echo id, so that we can see the results of that; let's go back and try it out. Click here on the link number four and here it is; it says four.

I'll click Go back; let's click two and it says two, so we're passing that data and on the next page, we are reading that data; now, that's sets us up for later on being able to take that value and make another database request based on that. That what we're going to eventually be doing. For now, we're just learning how to pass that value back and forth. If you want, you can also try adding additional parameters. For example, you could add page equals one ampersand and try passing multiple values if you want.

But I'll leave that as an exercise for you to do on your own.

2.3 Default Values for URL Parameters

In this movie, I want to talk about how to work with missing URL parameters and how to set default values for them. In the last movie, we learned how we can retrieve values from the associative array inside the GET super global. This process of retrieval and assignment works great, provided that there is a value to be found. In other words, if page wasn't sent in the URL, then a value would not be set inside the associative array and when PHP went to look for this value, it would raise either a warning or a notice to us telling us that the index can't be found.

Now, you can configure PHP to not show those warnings and notices, but it's a much better practice to go ahead and fix the problem. We want to check and make sure that the value is present before we try to retrieve it. One way that we can do that is by using an if statement. We can use if along with the PHP function isset to check and see if that value exists. So if isset then use that value and assign it to page. If not, then we can use some default value and assign that to page. This is great because now we've solved our problem.

Now, we make sure that the value is there before we try and use it and we also have the opportunity to provide a default value if we want. The only problem with this approach is that we just used five lines of code to do something that's fairly simple and that we're going to be doing over and over again, potentially for lots of different URL parameters. It's much more common for PHP developers to abbreviate this by using a ternary conjunction. It's just a one line way to write the exact same thing as that five lines of code up above.

The ternary conjunction uses a condition as its first part, you see we've got the same isset there, then it's got a question mark and then it's got two choices divided by a colon. The first one is the result if it's true, the second is the result if it's false. Ternary conjunctions are not limited to just checking whether something is set or not. We can use any condition that we want so they're common in other places as well. But here we're using it to check and see if the value is set. This is very, very common. If you're using PHP 7, there's actually something that makes it even easier which is called the null coalescing operator and it's a double question mark.

It's a special new operator introduced in PHP 7 that allows us to do this exact same thing even shorter. It essentially says check and see if there's a value there. If there is, use it. If not, then use this second value as a default instead. So that's become the hip new way to do it if you're using PHP 7 which I hope all of you are. If not, you can always default back to the old way of doing it which does the exact same thing. All three of these examples will have the exact same effect in your code.

In order to see this in action, let's go back to our website here and let's click on one of these. Let's click on this link here and you see it says id=4, right? So it's happily grabbing the id and returning it to us so we can see it. Now, let's just take that value away. Let's try and load show.php without any URL parameter and see what happens. You'll see I get back notice undefined index id. It was looking for an index called id in that associative array. It couldn't find it so it raised a notice to us.

So what we want to do is come back here and fix this so that doesn't happen anymore. So as I mentioned, the good way to do this in PHP 7 is just to do ?? and then put whatever you want as a default value in there. I'm going to just make a note here. This is PHP greater than 7.0. Now, if you are not using PHP 7, the way that we would have done it, let me just erase this, is using that ternary operator with isset. There we go, sorry.

Let me take GET id and just paste it right in here. So check and see if it's set. Then we have a question mark. If it is set, then do this. If it's not set, do that. So that's the old style way of doing it. So I'm just going to comment that out. I'm going to try and do it using this way because I do have PHP greater than 7 and let's try and see what we get as a value then. Let's come back over here to our page and let's reload it, I'll just click the reload button, and you'll see it comes back with one. That's my default value. So now it works in both cases.

I'll hit my back arrow. If I click on this one, it works to id=3. But if no id was sent at all, it goes back to default to one. So this is considered a best practice and a good habit to get in. Whenever you're pulling a value out of the super global, you want to check and make sure that it's there. And if you want, you can set a default value for it instead. You can also set it equal to null if you didn't want to set it to anything at all, but most of the time you're probably going to want to set it to some kind of a value.

2.4 Encode URL Parameters

Over the last few movies, we learned to send a value as a URL parameter. So far we used it to send simple data, like an ID or a page number. In this movie, I want us to discuss how to handle data, which could include certain special characters that require extra attention. And the reason why is because they might have special meaning to the URL. Let me give you an example. Let's imagine that we have a link that we want to use that passes along a query parameter that is the name of a company, so company equals, and then the name of the company. And one of our links happens to use the company name Widgets&More, and the name of the company is Widgets & More.

Notice the ampersand right in the middle of the name though. If you'll remember, that ampersand has special meaning to the URL. When we want to join together more than one URL parameter, we use ampersand to join them together. So, what we want is for the ampersand to be seen as being data, as simply being part of the string Widgets & More. The problem is that the URL might be interpreted to actually be separating out two different query parameters, company=Widgets&, a second query parameter More, and then nothing after it.

Right, we want to make sure that that doesn't happen, that the ampersand is seen as data, not as being a meaningful character in the URL. Now ampersand is one example, but there are a number of different reserve characters that we need to watch out for. The top row of this table shows a list of them. When we're constructing URLs for links, we want to encode these characters, so that they can't interfere with the function of the URL. Encoding a reserve character, means converting that character to its equivalent, and that's what's in the second row. Notice that they all have a percent sign, followed by a pair of hexadecimal digits.

Hexadecimal just means that in addition to zero through nine, we can use the letters A through F, as if they were digits too. Once it's encoded, it will no longer have its special meaning, and it will be treated simply as data. Then when the page is processed by PHP, we can decode these values to restore the original character. PHP give us two functions to perform this encoding, urlencode, and rawurlencode. They're almost the same, but there are some subtle differences. Both of these functions will allow letters, numbers, underscore, and dash.

Anything that's not a reserve character, pass through unchanged. However, any reserve charactering it encounters, is going to be encoded into its hexadecimal equivalent. Urlencode is also going to take the spaces that it finds and convert them to a plus sign. Spaces are not technically reserve characters, but they can cause problems, so it's a good idea to have those encoded as plus signs. Rawurlencode also converts spaces, but it converts them to %20 instead.

The reason why these handle it differently, has to do with a history of some technical specifications from a long time ago. What you need to know now, is when to use each one of these. Rawurlencode is what you want to use on the path, the part that says how you find the script that ought to be run. That's everything that comes before the question mark. In that case, you want all of the spaces to be encoded as %20. Urlencode is what you want to use on the query string. The query string is the part that comes after the question mark. It's all of those URL parameters that we've been talking about.

Those should be urlencoded. In that case the spaces are better encoded as being a plus sign. %20 would also work, but plus sign is a little more traditional. Now in truth, you're rarely going to use rawurlencode, because most of the time the path is not something that's being dynamically generated by PHP. It's usually something that you have total control over when you're typing that link into your html code. You decide what it's going to be. It's not something that gets determined on the fly.

However, the query string is very dynamic. It can contain values that come from the database, it can be values that you've assembled together in PHP, or it can be values that the user has given you. Maybe they've typed a query into a form. They're searching for a term in a search box. They type the term into global search, they hit search, and now we need to encode that value to make sure that it doesn't break anything when it goes up into the URL parameters. So urlencode, you're going to use way more often than rawurlencode.

So it's the one you'll use far more often. Now once the string is encoded, of course we need to then decode it on the other side, and PHP gives us two functions that do exactly that, urldecode, and rawurldecode. However, you're rarely going to need these. Why is that? Because PHP automatically calls the decode functions when it receives a URL. So as soon as PHP gets that URL, it parses it, it figures out where the query parameters are, it decodes the values, and then it puts them into your superglobal forget, so the values that are in the superglobal forget, have already been decoded, you don't need to do it yourself.

Let's try an example in our project. I'm going to go into Firefox, and I'm going to navigate the subjects, and let's just go to one of our pages here for show. So that's where we're going to go to. So on this show page, I'm going to just add in some links. Let's come down here, I'm going to paste them in. All of these just go to the same show page, and I'm just using different query parameters. Now, for each one of them, the value I'm putting in PHP. So I've got a inside PHP here, as an echo statement, in each and every case. I've got one that has a space, I've got one that has an ampersand, and one that just has a few crazy characters in it.

Now, this also didn't have to be like this of course, it could just be a link like this, and it would do the exact same thing. But I wanted to put the PHP there to start with, to make it easy for us to add urlencoding and decoding to it. Now, we can bring these up in our browser, and we can take a look at them, we'll just reload our page. There you'll see the three links, and I can click on them. And you can see that it did handle it okay, to put it up here in my URL. It was able to put it there. You see the space, you see that's a bit odd, you don't normally see spaces in URLs, and if we click this one you see that it says Widgets & More.

It seems to have put it up there okay, but what we don't know is how the web server in PHP would handle this on the other side. We don't know if this would be interpreted correctly once it's received on the other end, and that's what we want to be careful of. So let's add that urlencode to each one of these, urlencode. Then we'll just put parentheses around it. I'll just copy each one of these, and let's put our parentheses. There we go.

You still want to make sure you use echo. We don't want to just encode it and then do nothing, we have to echo back whatever our results are. But now let's take a look at what those look like. Let's come back to our web browser. And let's just reload our page, and let's click on that first link. You see we get John+Doe, that looks a little better. We get Widgets%26More, and we get a set of characters here. You can see that a couple of these got swapped out. %23, %3F, those got changed out to their other versions.

So that's all there is to it. Remember when we actually receive those values in our GET superglobal, those will automatically be decoded for us. All we have to do is make sure that we encode them. Now, we're going to use this a lot, and urlencode is a little bit long to type, so one of the things I like to do is I like to go over into my functions, and I like to create a new function. I like to call it just U, and pass in a string, and then in that string we're just going to return the value from urlencode on that string. Nice and simple.

And then I'd like to do another version of that that I call raw_u, that just does rawurlencode on the string and returns that value. This gives me something that's shorter, I can just simply put a U around any string that I want to send, and know that it'll get url-encoded. So let me just come back over here, and I can just change all these to just be my custom function which is U, which does the exact same thing. It just gives me a nice little shortcut. And just to close the loop, let's go back here and make sure everything works. Oops, I caught an undefined error function U.

The problem here, is that at the top of my page I have not required those functions yet, so let's just do that real quick right here at the top. Require once initialized, let's come back and let's try it. There we go, and now it works just fine, and we get our encoded version.

2.5 Encode for HTML

Over the last few movies, we learned to send a value as a URL parameter. So far we used it to send simple data, like an ID or a page number. In this movie, I want us to discuss how to handle data, which could include certain special characters that require extra attention. And the reason why is because they might have special meaning to the URL. Let me give you an example. Let's imagine that we have a link that we want to use that passes along a query parameter that is the name of a company, so company equals, and then the name of the company. And one of our links happens to use the company name Widgets&More, and the name of the company is Widgets & More.

Notice the ampersand right in the middle of the name though. If you'll remember, that ampersand has special meaning to the URL. When we want to join together more than one URL parameter, we use ampersand to join them together. So, what we want is for the ampersand to be seen as being data, as simply being part of the string Widgets & More. The problem is that the URL might be interpreted to actually be separating out two different query parameters, company=Widgets&, a second query parameter More, and then nothing after it.

Right, we want to make sure that that doesn't happen, that the ampersand is seen as data, not as being a meaningful character in the URL. Now ampersand is one example, but there are a number of different reserve characters that we need to watch out for. The top row of this table shows a list of them. When we're constructing URLs for links, we want to encode these characters, so that they can't interfere with the function of the URL. Encoding a reserve character, means converting that character to its equivalent, and that's what's in the second row. Notice that they all have a percent sign, followed by a pair of hexadecimal digits.

Hexadecimal just means that in addition to zero through nine, we can use the letters A through F, as if they were digits too. Once it's encoded, it will no longer have its special meaning, and it will be treated simply as data. Then when the page is processed by PHP, we can decode these values to restore the original character. PHP give us two functions to perform this encoding, urlencode, and rawurlencode. They're almost the same, but there are some subtle differences. Both of these functions will allow letters, numbers, underscore, and dash.

Anything that's not a reserve character, pass through unchanged. However, any reserve charactering it encounters, is going to be encoded into its hexadecimal equivalent. Urlencode is also going to take the spaces that it finds and convert them to a plus sign. Spaces are not technically reserve characters, but they can cause problems, so it's a good idea to have those encoded as plus signs. Rawurlencode also converts spaces, but it converts them to %20 instead.

The reason why these handle it differently, has to do with a history of some technical specifications from a long time ago. What you need to know now, is when to use each one of these. Rawurlencode is what you want to use on the path, the part that says how you find the script that ought to be run. That's everything that comes before the question mark. In that case, you want all of the spaces to be encoded as %20. Urlencode is what you want to use on the query string. The query string is the part that comes after the question mark. It's all of those URL parameters that we've been talking about.

Those should be urlencoded. In that case the spaces are better encoded as being a plus sign. %20 would also work, but plus sign is a little more traditional. Now in truth, you're rarely going to use rawurlencode, because most of the time the path is not something that's being dynamically generated by PHP. It's usually something that you have total control over when you're typing that link into your html code. You decide what it's going to be. It's not something that gets determined on the fly.

However, the query string is very dynamic. It can contain values that come from the database, it can be values that you've assembled together in PHP, or it can be values that the user has given you. Maybe they've typed a query into a form. They're searching for a term in a search box. They type the term into global search, they hit search, and now we need to encode that value to make sure that it doesn't break anything when it goes up into the URL parameters. So urlencode, you're going to use way more often than rawurlencode.

So it's the one you'll use far more often. Now once the string is encoded, of course we need to then decode it on the other side, and PHP gives us two functions that do exactly that, urldecode, and rawurldecode. However, you're rarely going to need these. Why is that? Because PHP automatically calls the decode functions when it receives a URL. So as soon as PHP gets that URL, it parses it, it figures out where the query parameters are, it decodes the values, and then it puts them into your superglobal forget, so the values that are in the superglobal forget, have already been decoded, you don't need to do it yourself.

Let's try an example in our project. I'm going to go into Firefox, and I'm going to navigate the subjects, and let's just go to one of our pages here for show. So that's where we're going to go to. So on this show page, I'm going to just add in some links. Let's come down here, I'm going to paste them in. All of these just go to the same show page, and I'm just using different query parameters. Now, for each one of them, the value I'm putting in PHP. So I've got a inside PHP here, as an echo statement, in each and every case. I've got one that has a space, I've got one that has an ampersand, and one that just has a few crazy characters in it.

Now, this also didn't have to be like this of course, it could just be a link like this, and it would do the exact same thing. But I wanted to put the PHP there to start with, to make it easy for us to add urlencoding and decoding to it. Now, we can bring these up in our browser, and we can take a look at them, we'll just reload our page. There you'll see the three links, and I can click on them. And you can see that it did handle it okay, to put it up here in my URL. It was able to put it there. You see the space, you see that's a bit odd, you don't normally see spaces in URLs, and if we click this one you see that it says Widgets & More.

It seems to have put it up there okay, but what we don't know is how the web server in PHP would handle this on the other side. We don't know if this would be interpreted correctly once it's received on the other end, and that's what we want to be careful of. So let's add that urlencode to each one of these, urlencode. Then we'll just put parentheses around it. I'll just copy each one of these, and let's put our parentheses. There we go.

You still want to make sure you use echo. We don't want to just encode it and then do nothing, we have to echo back whatever our results are. But now let's take a look at what those look like. Let's come back to our web browser. And let's just reload our page, and let's click on that first link. You see we get John+Doe, that looks a little better. We get Widgets%26More, and we get a set of characters here. You can see that a couple of these got swapped out. %23, %3F, those got changed out to their other versions.

So that's all there is to it. Remember when we actually receive those values in our GET superglobal, those will automatically be decoded for us. All we have to do is make sure that we encode them. Now, we're going to use this a lot, and urlencode is a little bit long to type, so one of the things I like to do is I like to go over into my functions, and I like to create a new function. I like to call it just U, and pass in a string, and then in that string we're just going to return the value from urlencode on that string. Nice and simple.

And then I'd like to do another version of that that I call raw_u, that just does rawurlencode on the string and returns that value. This gives me something that's shorter, I can just simply put a U around any string that I want to send, and know that it'll get url-encoded. So let me just come back over here, and I can just change all these to just be my custom function which is U, which does the exact same thing. It just gives me a nice little shortcut. And just to close the loop, let's go back here and make sure everything works. Oops, I caught an undefined error function U.

The problem here, is that at the top of my page I have not required those functions yet, so let's just do that real quick right here at the top. Require once initialized, let's come back and let's try it. There we go, and now it works just fine, and we get our encoded version.

2.6 Challenge -> Add Pages

It's time for your first challenge assignment. Over the last two chapters, we've covered the basics of building web pages with PHP. I've been demonstrating concepts by working with the subjects area of our content management system. From our initial project blueprint, we know that our content will be divided into subjects and into pages and we'll need to be able to manage the pages of our project as well. Your challenge assignment is to do the same work that I did on the subjects area, but to do it for the pages area. Let's run through some of the points that you'll want to make sure that you hit.

First, we know that we're going to need to have a link from the main staff menu that'll take us to this pages area, so we want to put a link from /staff/index.php that'll take us to /staff/pages/index.php. We already had a placeholder in place for that. You're then going to want to take that placeholder and replace it with the correct HTML and PHP for the pages index, that is a list of the pages that we can work with. You want to make sure that it loads up the initialize file that we created. You want to make sure it includes the correct header and footer that we used as a shared header and footer.

And you want to have it go through and list all the different pages as a table. You can use the /staff/subjects work that we did as a reference. I don't expect you to be able to do it all from scratch. However, it's very much to your benefit and will help you to learn if you and try do as much of it as you can on your own. Don't simply copy and paste from the work that we already did. Try to write it yourself. That's the best way that you can learn this stuff. You'll also want to make sure that you add a pages variable that contains an array that holds a list of pages.

You can structure it to look exactly like what we had for the subjects variable on subjects/index.php. The name that you use for those different pages is really up to you. Once you have your list of pages, then you'll want to link each page to /staff/pages/show.php. You'll need to create that page and you'll want to make sure that you include the page ID as a URL parameter in that link. You'll want to send that link over there and then you'll want to be able to retrieve and display it on the show.php page, just like we did in the subject page.

Now later, we're going to learn how to use that ID to go to the database and retrieve more information. For now, it's enough to just simply retrieve it and be able to display it, to know that it was retrieved successfully. While you're doing all this, make sure that you use the file path techniques that we learned for including files, so that's include, require, include once, required once, and then the constant that we set for the shared path that we made use of. And also use the URL techniques that we learned to help you when creating links. Remember we set a constant for www root and we created a helper method that was URL four.

Also make sure that you encode any dynamic data that's being used for links and for HTML. It's dynamic data that we're really concerned about here. We want to make sure that you use urlencode for dynamic data used in URLs and HTML special chars for any dynamic data output to HTML. And last, make sure that on all of these that you set the page title appropriately for all of the pages. Again, if you get stuck, go back and watch the movies that we did before or review the work that's already in the subjects directory because it's going to be very similar.

In the next movie, I'll show you the results that I came up with.

2.7 Solution -> Add Pages

I hope you were able to complete the challenge assignment. In this movie, I'm going to show you the solution that I came up with. Make sure you watch it, because there are going to be a few extra points that I want to make along the way. Let's start by looking at it in a browser, and then we'll look at the code second. First, you can see that on the staff menu area, I've added a new link for my main menu to pages. When I click on that link, it takes me to staff/pages/index.php. And I've replaced the placeholder content that we had there, with a list of the pages. So now, I've got a list of pages, showing me the basic attributes of these four different pages we would potentially manage in the future.

Now, eventually, again, that'll be from a database. But right now, we're just iterating through a sample list. So I've got a list of those, and each one of those, you can see has an ID associated with it. And each one has a link that says view. It'll take me to the show page, and when I do, you can see it also includes the url parameter id=2. Now, on this page, I'm also using the same header and footer, and I'm showing the page ID equals two. I'm retrieving that, using php, from the parameters, and then displaying it on the page.

I've also added another link here called back to list, and that just allows me to easily go back to this list page. Now I can click on a different one, ID three. Click on a different one, ID four, and so on. Okay, so now that we see what it looks like, let's go over and take a look at the code. As I mentioned, the first thing I did was go to the staff menu, and I added a new link that goes to pages. And I wanted to link that to staff/pages/index.php and I use that url for helper method that we created, that helps us to be able to create urls that are absolute, relative to the root of the entire website.

So that's why I'm declaring staff in front of it. It's because it's from the root of the website, from the root of the public directory, going forward. All right, so then we have that page. Let's look at the index.php page that's inside pages. This had placeholder content before. Now, you can see we're using require_once and we're locating initialize.php. Once we do that, it loads up all the functions, and constants, and everything that we might need on this page. So everything is loaded, and ready and waiting for us. You can see that I have $pages as a variable.

That's equal to an array, containing four other arrays. And those are my placeholders for the different pages. Again, this is a stand-in for a database in the future. I went ahead and just gave some sample names to those pages. Globe Bank, History, Leadership, Contact Us. It really doesn't matter what you call them. The important thing is that they all have an ID, so that we can use that ID later on. You can see I gave a page title to this page, and I used include, along with the shared_path constant, in order to locate the staff header. Then I've got some html here, to list off my pages, an h1 at the top that says pages.

I've got some placeholder html for when we're able to create a new page later on, and then a table that lists off my pages. Here's the header at the top, saying what all the columns will be. And then I've got a loop using foreach that goes through that array, and uses each array inside there as a page, and I output, the ID, the position, menu name, and whether it's visible or not. Notice that I'm using h in front of each of those. I'm escaping each one. That's the helper method we created up here, for htmlspecialchars.

So I'm using that, in order to escape these values, and make sure that they're safe for html. Now in this case, you may be thinking, "Well that seems like overkill. "These values up here, we know what they are. "We just set them, I set ID equal to one. "I know it's safe. "There's no chance that it is equal "to some bit of java script or bad html." But the thing is, it's a stand-in for a database, and in the future, that is going to be dynamic data. So it's important that anytime this data is dynamic, we just take that extra step.

It's a precaution to make sure that we're safe, and it's one that you always want to take. I did not do it for visible here, because I'm not actually outputting the value of visible to the page. I'm checking the value of visible, to see if it's one, and what I'm outputting is either true or false, and I have total control over those strings. They're not actually dynamic, so I don't have to worry about those. Then here, you can see that I'm creating the url. It'll take me to the show page. It has a url parameter for id= and then I'm using the page ID.

Notice here, that I'm using two kinds of escape on it. The first is that I'm url encoding it, to make sure that it's safe to be included in the url. And the second is that I'm html escaping it, because I also want to make sure it's safe to put in my html, because again, this is a dynamic value that I'm about to put on my html page, so I just want to check it and make sure. And then, down at the bottom, you can see that I have the include, using the shared_path to load in the footer. On the show page, I did something very similar, with having the initialize, using the same header and footer, and I went ahead and gave it a page title of show page.

You can see that I'm finding the ID here, using id= and that superglobal for get, and I've got a default value, in case something wasn't sent. I'm using that new no coalesce operator, from php seven. And then down here on the page, you can see I'm just echoing that value back, and I'm escaping it, because again, I want to make sure that whatever value is passed in that url is safe to put in my html here. You can see the back to list link that I created, that just takes me back to that pages/index.php.

Notice also, that I created a double arrow, going backwards, with this and L-A-Q-U-O semicolon. That's an html entity. Just like the html entities that we were using when we escape our html, there are other html entities that are available to you. I just wanted to show you that there are more of them out there, besides the ones that are created for us using htmlspecialchars. Once I had done all that work for my pages, I realized that my subjects needed some of that same attention. So I went back over to my subjects, and I made sure that I escaped all of those values, so that I used h in front of them, the exact same way, and I escape and url encode the subject ID.

And, on the show.php page, for subject, I gave it the same treatment, with the header and the footer, and the page title, and the back to list link, just so that it would have the same kind of thing that the page has, so that those are a little nicer as well. And then the very last detail that I want to show you, is that I'm setting page title here. Page title is probably something that I have control over. It's a string here. But notice that in the staff header, I'm using that page title. I'm outputting it into my html.

Now, as long as I'm using strings that I provide, that's not a problem. But the moment that I might potentially start using dynamic data in there, I could inadvertently create a problem for myself. I could accidentally put dynamic data in my page title. What if, for example, my name of my page wasn't just show page, but show page colon, and then whatever the name was. Now that's dynamic data that comes from the database. I could make sure that I escape it there, but it's better to just make sure that I do it all the time.

Right before I drop it onto my page, let's escape that value, and make sure that it's safe. So I went ahead and added that to my staff header as well. So hopefully you did well with the challenge. I know that there were a few other extras that I threw in there as well, that weren't specifically part of the challenge. Take a few moments, and make sure that you add those to your project as well.

3. Headers and Redirects

3.1 Modify Headers

In this chapter, we will learn about page headers and page redirects. Page redirects in particular are an essential web development skill. We're going to begin by learning about headers and how to modify them. Let's begin by reviewing the way in which a web server processes a request that comes from a browser. A request goes from the browser, to the web server software. The web server software looks for the correct PHP file and then reads that file, processes the PHP code that's inside, assembles an HTML response and sends it back to the browser.

The web server also sends a small amount of data just before the HTML response. Which provides basic information to the browser about what to expect from the content to follow. It's similar to the cover page sent with the fax document telling you how many pages total to expect in the fax. This data is called the HTTP header and every response that uses the HTTP protocol has one. Here's an example of an HTTP header. You can see it says the protocol is HTTP.

It also says the status code is 200 OK. Indicating that the request was handled without errors. It has the date, some information about the server, and information about the type and the size of content to follow. Usually you don't see or even need to think about this header information. It's automatically constructed by the web server. But we can also use PHP to give instructions to the web server on how to construct this header. We do that using PHPs header function. It expects a string as an argument. That string can be any line that we want added to the header.

If the line contains some standard information then it's going to be used in place of the default settings. For example, I can tell it that the content type should not be HTML but that we're about to send a PDF file. Another common use is to respond to the browser with an error message. Instead of saying that the status is 200 OK, you can say that the page was not found with a 404 error. Or that something went very wrong with a 500 error. You can also use headers for more advanced techniques. Like sending attachments and setting page cache controls.

We're not going to talk about those here. There's an important point to remember about headers. And that's that headers come before all other page data. Remember they tell the browser hey browser here's what data is coming next. And they're required by the HTTP standard to proceed any communication. That means that any changes we want to make to the header has to be done before we output anything from our file. If we send even a single character to the user's browser. Then the header file is already on its way out the door right ahead of that data.

At that point it's too late to make changes to the header information. And I mean anything. Even if it's a blank space or a line return. Those count. And you have to watch out for spaces and line returns that might be an included files as well. A space is allowed inside a block of your PHP code, just as long as that code doesn't actually output anything. We're going to revisit this topic again when we talk about output buffering later in this chapter. For now just remember headers must come first and any changes we make to headers must come before we output any data.

Let's trying modifying our headers in our project file by going into our functions.php and creating a couple of new functions that will send error messages. Error 404 and we'll make another one down here that's going to be function error 500. So in order to return a 404 error we need to use that header function and we need to provide a string that's going to tell it what it should return.

Now we saw that we could provide the protocol http slash one point one et cetera but a better way to do that since the protocol could potentially change is to use the super global for server and then ask it what the current server protocol is. So we'll just be repeating back whatever that current server protocol is and then we'll append on to that 404 Not Found. After that we're just going to call exit. Now you could render your own 404 page here instead. Exit is just going to quit. It's going to say, you know what, don't do any additional PHP, we're done.

Just send what you've got back to the browser. You could have something that would actually render a PHP page here instead. So that you would have something to show the user that it was custom. We're not going to do that. And I'm just going to copy this two lines down here. But this time instead of 404 not found it's going to be 500 internal server error. Okay, so now whenever we call these functions. It will change the header and immediately exit our PHP. Let's create a way that we can try those out.

I'm going to go into my subjects directory and I'm just going to create a new file in there which I'm going to call new.php. Eventually new.php is going to do more interesting things. For now we're just going to use it to test out these errors. And I also want to grab this line from the top of my index.php where I get initialize because I want to have that as well. I want to make sure that I load in those functions that we just created. So that's going to be on my new.php page. So now let's add some PHP code. php and let's set set variable test, equal to the value sent in the URL for test.

And we'll use null coalesce operator to set it to a default value if it doesn't exist. And then we'll check if test is equal to 404, then, let me just close that parenthesis and then type the curly braces. I'm going to call error underscore 404. That's that function I just created. And then I'm going to copy that and let's add elseif test is equal to 500 then the error will be the 500 error.

Else echo no error. And then let's close our php tags. Okay now remember, we said that before we can modify header data, there can be no white space. Well, guess what? Look at this right here, I have white space. It's right here after the require once. I want to remove that. I also still have white space because I have a line return in between those. That can count too. So I'm actually going to remove that as well. My php tag now is going to open right here at the beginning the very first character of the file is opening the php tag.

And then it ends at the end. There's no extra white space before we get to having those headers. White space that's inside these PHP files that don't actually output anything, they're not a problem. It's only once we actually output to this page that it's an issue. Right, so let's save it and let's try it out. I'm going to go into my subjects area and instead of index.php I'm going to just change this to be new.php. So we get no error to start with. Now I'm just going to change this to be test 404.

Now it returned a 404 error. But that's really hard to see in the browser because we didn't provide a custom 404 page back. So I would just want to show you a way that we can handle that. I'm going to copy this URL. You don't have to follow along with me. But I just want to show you that in my command line there's a tool called curl. And if I tell curl to use the --head option it will let me look at the headers that come back. Let's first look at the header when I don't provide anything. You'll see it gives me back a basic header here, HTTP 200 OK. Now when I go back and I put in test equals 404, you'll see it gives me a 404 not found error.

It modified the header. And let's do the same thing, we'll test out our 500. And you'll see that we get back that 500 server error. Now those can be handled in a variety of different ways. We could have a custom error page re-returned, our web server can be configured to have a error page that it returns. Sometimes even the client, the browser can have something configured. Now that we know how to modify the header information we're ready to talk about page redirection in the next movie.

curl --head http://devserver/globe_bank/public/staff/pages/new.php
curl --head http://devserver/globe_bank/public/staff/pages/new.php?test=404
curl --head http://devserver/globe_bank/public/staff/pages/new.php?test=500

2.2 Page Redirection

In this movie we're going to build on what we just learned about modifying header information to learn how to perform Page Redirection. In http a webserver can tell a webrowser that it ought to go to a new URL by something known as a "302 redirect". A 302 redirect has two parts to it, both of which are items that are in the header information that's sent back to the browser. The first is a status code of 302 Found and the second is a location attribute indicating the new URL that the browser ought to try instead.

PHP's smart enough to know that if we're setting the location then we also want to set the status code to 302 at the same time. We don't have to manually set it. Just by saying "header", and then telling it the new location, it knows this must be a redirect because that's the only thing the location attribute is used for. A 302 status code in the header indicates to the browser that it should immediately make a new request to this new location. It ignores any page data that might follow, in fact it expects that there won't be any.

The re-request happens very fast in the background so that the user doesn't even know that it's happened. Let me give you an example of the most basic usage. Let's imagine that we have a browser and that browser's going to make a request to our web server for a page that we'll call old.php. But let's say that the data that the user's looking for has actually moved to a new location, it's actually belongs somewhere else. So, instead of providing the data the user's looking for, old.php is helpfully going to tell the browser where it can find the data that it's looking for. So instead of responding with html it's going to respond with a redirect, 302 Found, and then the new location.

In this case the location is new.php. That request happens very quickly and immediately afterwards without any indication of the user, the browser will issue a new request for new.php. That page is legitimate and has the information the user's looking for, and so it returns that data back to the browser. Now, this is a very simple example. One where one page does nothing except immediately redirect the user to another. But it doesn't have to be that way. Redirection can be used for other cases and it can happen after other code executes first.

Let me give you another example. Let's imagine that the user submits the username and password on the login page. They want to login to a website. PHP code then will check their username and password to see if they're correct, and if they are the user is going to be sent to a success page. Maybe that's a menu of options or their home page, their personal homepage. But if it's not correct, then the user's going to be sent to a failure page. That failure page might say sorry it was incorrect, or it might be the same login form again so they can try again with a new username and password.

That's where the redirection comes in though. Being able to send them to another page in each case. A page that's a different one than the page that they originally requested. I'm sure you've also seen this in eCommerce. You submit an order, the order is processed, and then you're redirected to a receipt page at the end. And you can tell that you've been redirected because the URL in your browser actually changes. Now let's remember that page redirection has one big caveat which is that page redirects are being sent in the header information.

And the headers are sent before the page data, they precede any page data that's sent. Therefore header changes must be made before we have any html output. Even spaces or line returns. Therefore, page redirects must be sent before any html output. Now we'll revisit this again in the next movie where we talk about output buffering but for now just know that is is something you have to be careful of. Setting headers, making page redirects, need to happen before html output is sent back to the browser.

Let's try an example of a redirect in our project. In the last movie we created new.php inside subjects and we created some test code so we could test out some errors. Let's just add in another case here and let's make it elseif(test == 'redirect') so if we send redirect in the URL then it will perform a redirect for us. So, what does that redirect look like? A redirect is, header and then ("Location: , only one space, and then the new location we want to go to.

I'm just going to put index.php. I'll put a semi colon at the end and then it's a good practice to put exit afterwards so that no other code on the page executes. It just simply quits PHP right away. All it does is send back those headers and then the browser will make its new request for index.php. Let's try it out, let's save the file, let's come back over here, we'll want to make sure that we're on new.php and instead of test 404, I'm now going to test out a redirect. Test equals redirect, boom, look at that.

It redirected me to my subject's page. Notice that the URL changed. You can try it again if you want to see it happen. It happens very quickly, the request is sent to the web server, the web server says, "Hey browser, go to this new page instead," and the browser makes a new request for this index.php. Before we leave this, let's just make a couple of improvements. The first is that instead of putting index.php in here let's actually concatenate it together and let's use that URL four that we had so that way we can just make sure that we're able to locate things consistently in the same way, index.php.

So that'll work exactly the same. The second thing that I want to do is, because I'm redirecting I find header a really hard way to remember what I'm doing, to remember that I'm redirecting. I think it's much better to have a function that'll do this for us. So I'm going to copy these two lines, I'm going to go to my functions.php and right here after "error", let's put in a new one, function redirect_to, and it's going to then have a location. So we're going to provide the location that we want to reidrect and what's it going to do? Well, it's going to set the header equal to, and we'll just take all of that out that we just did and put in location instead.

See how that works? So it gives me an easy way to say redirect to, and it's very clear what I'm doing in my code, but what it actually does behind the scenes is it sets that header for us. Let's save that and let's just go back over to new.php and let's use that instead. So it's going to be, redirect_to, and then we'll still use that URL four though to make sure we have the right one. There we go, two closing parenthesis. So URL four, this path. And then we don't need exit anymore because that's now taken care of for us in our function.

Let's try it out and make sure that it works. Let's go back here, let's go to new.php first and then let's tack on, test=redirect. Watch how fast this happens. Boom, right away I'm redirected to the new spot. Page redirection is an important skill to have in your web development toolbox.

2.3 Output Buffering

In this chapter, we've been discussing headers and page redirection. One of the important points, which has come up a few times, is that it's essential that any changes to the headers come before any output to the HTML. In this movie, we'll look at that a little closer and also learn how we can use output buffering to help us. Let me start by giving you a metaphor for illustration. Let's imagine that our PHP code is a faucet, and our web server is a glass. Every time our PHP code outputs some data, it goes into the glass like drops of water.

As soon as the web server receives its first drops of data, it creates the headers for the data and they can't be changed. Once the PHP code is complete, the web server will take the accumulated data and send it to the users browser. Now, let's imagine a second example where our PHP code goes not directly into the glass but instead into another container. This container is the PHP output buffer, and it's like a measuring cup. The output from the PHP code goes into the output buffer and then when it's full, or when the PHP code is done, we take all of that data in the buffer, and we pour it into the web server.

Then the web server returns the data to the users browser, just like before. That's how output buffering works. Here's the thing, while the data is in the output buffer, it's still editable by PHP. We can monkey around with the headers all we like. It's only once they get sent to the web server that they can't be changed. This gives us flexibility because its frees us from having to be certain that no whitespace or line returns happen to come before a header changer or a page redirect. We just have to make sure that the output buffer is turned on and any of our whitespace headaches disappear.

There are two ways that we can turn on output buffering. The first is to turn it on in your php.ini file. This features become so common, that in most cases, it should already be turned on by default. One way to find out is by using the phpinfo function. Inside PHP tags, put phpinfo that's all you need to have inside the file, and then I'll take that file and I'll drag it into my web server here, right into my document root for sites. Then I can come over here to FireFox, and I can just load that page up.

My_phpinfo.php and you can see that I can see all sorts of information about the configuration I have. I'm going to do a search on this page for output buffering. You can see that down here it has a listing for output buffering and it has a size. This is the number of characters that are going to be buffered. The fact that I have any number there at all, means that output buffering has been turned on. If it said off or had no value, then it would mean that it's not turned on. This tells me my output buffering is turned on.

This page also tells us where our PHP.ini file resides. You can see right here, loaded configuration file, and it gives me a path to my file. I'm going to copy that path and then from my terminal, my command line, I can take a look at that file. I'm going to Linux's nano in order to be able to look at that file. You can bring it up in another text editor just as well. I am going to use ctrl + w to search for output_buffer and you'll see that the first thing it gives me is a commented out section here, telling me about the different values.

That's not what I want. The semicolon in front lets me know that it's a comment. I'm going to ctrl + w again and hit return, and this time it gives me the real configuration. Output buffering has been set to 4096. It gives you some more information here about what settings you might use in different cases and how you could set it, what you could set it to. Notice though, that it's 4096. That means I can send 4,000 characters to the output buffer, to my measuring cup, before they get dumped into the web server. I have 4,000 characters to play with before my headers are set in stone.

You can set this to a higher value if you want, but 4,000 is generally a good number to have. You usually don't need something more than that. Another way that you can turn output buffering on, is from your PHP code. PHP gives us two functions, ob_start and ob_end_flush. Ob start, of course, starts out with buffering. Ob_end flush ends buffering and flushes whatever results have accumulated over to the web server. Ob start has to come before any content, the same as headers.

We need to have output buffering enabled otherwise our data is going to start being sent over the web server before it's turned on. It also doesn't hurt to use ob start a second time if you've already got it turned on in your PHP file. It doesn't do anything bad to call it twice. Which one should you use? My recommendation is that it's best to turn output buffering on in your PHP.ini file. Just have it there all the time so that you're always using it. It's also a good idea to use ob start any time that the code you use may be ported to other servers, especially if those other servers could potentially configured not to have output buffering turned off.

We wouldn't want our code to stop working because we depend on having output buffering. It's not a bad idea for us to have both. One final point is that you don't explicitly need to call ob end flush because when you get to the end of your PHP code, it will do that step for you. Even though we have a function that will allow us to flush it manually, it's rare that we actually need to do it. I'm going to add it to my project, so that we always make sure we have output buffering enabled. The way I'm going to do that is in this initialize.php since all of our PHP files are calling this file to begin with, this seems like the appropriate place to put it right at the beginning.

Ob_start and that lets us know that output buffering is turned on. Let's save our file. Let's just make sure that we haven't broken anything, we'll come back to FireFox, we'll click on our menu page, and everything works just fine. Click around, now our output buffering is on. It's buffering the page contents, but then in the end, it's taking those and flushing them to the web server, and then the web server is then returning them to the browser.

4. Build Forms with PHP

4.1 Build Forms

In this chapter, we will learn to use PHP to build pages which have forms for submitting data, and we'll begin, by reviewing the basics of HTML forms and then adding some forms to our project. There are two main ways in which we can interact with websites using the HTTP protocol. The first is what we've been doing in the last few movies and that is, GET requests. Whenever you type a URL into your browser bar or when you click on a link, you're going to be issuing a GET request for the server, and it's called GET because the idea is that we're getting back information.

We're making a request to read information back from the server. Forms work differently, because with forms, we're not just reading data back, we want to submit data to the server, so they use a different method, they use POST. So those are the two main ways that we communicate with the web server. They're not the only ones but they're by far and away the most common. Links allow us to GET data; forms allow us to POST data. This is what a basic HTML form looks like, and you'll notice that inside those form tags, I have attributes for action and method, and the method here is post.

It doesn't have to be post, but most of the time that's what you're going to want it to be. The action is where were going to submit this form data to. It's a lot like the href that's inside the link. It says where this data will be submitted. Inside the form, we've got all of the form tags. All of the places we want the user to fill out so that we could submit that information. You can see I've got inputs of type text for city, state, and zip code. Those names are going to be used to label the data that's submitted, and then the last one you can see is just a big Submit button, and the value that's on that attribute is what the button text is going to say, in this case, it'll just say Submit.

Let's add a form to our project. I want to start by adding one to our staff subjects new page. We were working with this in the last chapter and we went ahead and added some code at the top. We can leave all of that, but let's take out this last bit here that says echo 'No error' and the else that comes right before it, so that it won't actually output anything except for our form. Now right below all that php, I'm going to paste in some code, quite a lot of code actually, and it's included in the Exercise Files if you want to get it from there. Let's take a look at what we've got. It's very similar to what we had for other pages. You can see I'm setting $page_title to 'Create Subject'.

We've got the header being put in the top, inside my content div. I've got a back-link to take me back to the subjects list, and then, I've got another div here with an h1 for Create Subject, and then my form, this is the key part of this page. You can see that my form has a blank action for now. We'll come back and talk about the action later, and my form has a method of post for submitting it, and then I've got a series of form fields. You see I've got an input of type text here from menu_name, and I'm also using some HTML just to maintain the structure of that on the page.

I like to use these dl, dt, and dd tags, that stands for data list, data term, and data definition. You could also use div's or span's or table, whatever you want, but the overall idea is that we just have a label here followed by the field that we're going to fill out next to it. I've also got one for position, which is going to be a select option, where we can pull down a list of choices, and then, I've got a checkbox here for whether the item ought to be visible. So it's an input of type checkbox, the name is Visible, and the value is 1.

Now you'll notice that in addition to the checkbox, I also have an input of type hidden right above it, which has the same name. What's that about? Well here's the thing and this is a very important point to remember. When we have a checkbox, if the checkbox is checked, then our form data will send this value, so it'll have a value of visible=1 in the form data that it sends, but if our checkbox is not checked, it's not going to send visible equals nothing, it's going to send no attribute for visible whatsoever.

It just won't be included in our form data as if we never put it on the form at all. That's just how HTML works. That can be undesirable when you're processing the form because we want to know that visible was there and that the user chose not to check it. So in order to do that, one work around is to put a hidden field right before it, a hidden input with the same name and with a default value. So now what happens is if the form is checked, then this value takes precedence because it comes later on the form, that's the value that's going to be submitted with the form.

If it's not checked, than this line, is not going to output anything at all, and the only thing submitted in the form data is going to be visible=0, because it's still in the hidden input. It's a handy trick and it's an important part of any web developer's toolbox, and then down here, you can see I've got an input of type submit and my footer at the bottom. Let's save our page and before we go look in our browser, let's also go to subjectsindex.php, and right here, you can see I've got a place holder for a Create New Subject link.

Let's go ahead and put a link there for that. So php echo url_for() and what is our URL going to be? '/staff/subjects/new.php', that's going to be the link to it. Let's go try it out. I'll go into Subjects, Create New Subject, when I click on the link, now I get a form that allows me to create a new subject. I can type the Menu Name here, I can choose the Position, and I can check whether it's Visible or not, and then submit the form.

So this form will allow us to create a new subject in the database. Now let's give some thought to once we create that subject, what happens if we want to make changes to it? We want to edit the existing data that's in the database. We would want to have a form for that as well right? Let's do that by creating a new page here. Let's call it edit.php, and I'm going to go to new.php, and I'm going to copy all of this information, and then let's go over to edit.php, and let's paste it all in there.

Then let's go up to the top of the file, and let's go down, and see what changes we need to make to make it an edit page. Obviously it's not going to be called Create Subject, it'll be called Edit Subject. Scroll down a little further, and we can change this class to say edit, and change this h1 to say edit. Let's scroll down further. Now all these form fields are the same. We still want to be able to edit the menu-name, we still want to be able to edit the position and the visibility, so those are going to get reused. The label on the button will also say Edit Subject, and that's it.

Let's save it, and let's go over and let's take a look. I'm going to change new.php to be edit.php, and there we are. Now we have our Edit Subject form. This is what would allow us to edit the subject. Now, eventually, we're going to want to actually go to the database and get that existing subject data and pre-populate those fields with the current values. That's what's different between the new and the edit forms. New, will not need to have an existing object in the database, right, we're creating one from scratch.

Edit, is going to be using existing data and just allow us to make modifications to it. So, let's keep that in mind. Most of the time, the forms between the two are going to be almost identical, because data that we create in the database is probably data that we want to edit later on, but they're not going to be exactly the same. For one thing, we know that our edit subject is going to need to find an existing record in the database. So when we come back over here, let's go take our link from Create New Subject, let's copy it, let's scroll down here to where we have a place holder for an edit link and let's paste that in there.

It's not just going to be going to the edit.php page we just created, it's also going to need to look up the existing record. So we're going to need to tell it which record that is, and we know how to do that 'cause we did it up here for show. Let me just copy all of this right here, and there, now you can see it's going to append the subject id to the end. So now the edit page is going to know what our current subject is, what are we looking for? It's going to go to the database, it'll get that information out, it'll pre-populate our form with it.

We didn't need that up here for new. New didn't need to have any additional information, it just needed to display a blank form. Let's save that page. Let's go over here and let's try it out. Let's go back to this, and now when I click on Edit, next to Small Business, you can see it says id=3, So now it would know to go to the database and retrieve the subject that had id 3, and use that to pre-populate these fields. There's another difference too which is that this action is going to be different here at the top as well, because the action involved with creating a new subject in the database, is probably going to be different than the php code that we need to edit an existing subject in the database.

So the form action is likely to be different as well. So while there are a number of similarities between our new and edit forms, they're not exactly the same. 

4.2 Use Form Parameters

In the last movie, we added some forms to our project. When one of those forms is submitted, the page that receives the form is going to need to work with the form values. PHP takes these form values and automatically assigns them to an associative array where we can access them. That array is stored in a super global variable called $_POST, or dollar-sign, underscore, and then in all caps P-O-S-T. Remember, for URLS and links, which were GET requests, we access the URL parameters using the super global $_GET.

It makes sense, then, that with forms, which are POST requests, we would expect to find the form parameters stored in the super global for $_POST and PHP puts these values into the $_POST super global before our page code starts processing, so they're there right from the start. But, unlike GET parameters, we do not need to do any special encoding on form parameters before we send them. There are no reserved characters that we need to worry about. HTML takes care of all of that for us already. The way that we access these values is just like we did with the $_GET super global.

We simply ask for the name of the attribute we want to get out of the associative array. So here I'm getting the value that was sent in for name. It's also a good practice to make sure that value exists so we don't accidentally get a warning or an error so we can use either the ternary operator that'll check to see if it's set before we use it or if not use a default value, or if you're using PHP greater than 7, you can take advantage of that null coalescing operator, which does the same thing. If $_POST['name'] is there, use it; otherwise, go to the default value.

In my project, I've already added a page called create.php in the subjects directory and you'll also find this in your exercise files. It's a very simple page. It doesn't even load up our initialize file or anything like that. All it does is it simply accesses this $_POST super global and it asks for the values that have been sent in for menu name, for position, and visible and assigns them to local variables and then we have a bit more PHP that just simply displays those back to us on the page so we can see what they look like. So that's it, we're just simply doing a simple exercise to read values that have been submitted to this page by a form.

So this page is called create.php. We just need to submit our values there. So let's go to new.php and let's just change our action link here to go to that new page. So I'm going to use "<?php echo" and I'm going to use my "url_for" function again here, make sure that I have a good URL that I can use, and it's going to be called /staff/subjects/create.php. That's it, I don't need to provide anything else, I just tell it what page to send, the package of all of this form data.

Let's try it out. Let's save it, let's go to Firefox, let's click on "Create new subject." If you already had this page loaded, make sure you reload it because we want to make sure that we have that action at the top of our form so it knows where to submit it. Now let's try "Testing," position 1, visible true. Click "Create subject." Look, it took us to create.php, it read in the form parameters, here's "Testing," position, visible 1. We can click back, we can change it to "Testing Again," change it to not visible, and click "Create subject." There we go, again, create.php, our menu name, our position, and visible.

That's all there is to reading back these form parameters. Now you may be wondering, well, what about when we take this code here and we want to put it on our edit form right here, I'm not going to paste it in yet, but for this action, the edit action needs to be a little bit different because the edit action needs to also be able to pull up the existing subject from the database. It needs to know which one we want to edit. We've given it a menu name and a position and visible in our form data, but we didn't tell it which one. Well, our action here would need to include the ID, the ID of the subject we want to edit, so we would want to include that as part of the URL.

So you may be wondering, what about the fact that we're using both GET parameters and POST parameters? That's not a problem. PHP will take the URL parameters that come in from the URL and put those in the $_GET super global and it will take all of the parameters that come in from the form and put them in the $_POST super global. We can use both of them together. For now, we'll leave this edit action blank because I have a different idea in mind for what we'll do with it later on. 

4.3 Detect Form Submission

In this movie, we'll discuss how we can tell when a form has been submitted. Let's begin by understanding why we might want to know that. Here I am on the create.php page that we created and used in the last movie. The way that we used it is that we had a new dot php page that submitted its form data over to create.php, so this was a POST request to create.php, which contained the form data here and then we had create.php that processed that data. It did some very simple processing, it just simply read the values back and put them on the screen for us.

But I want you to notice that even though we made a POST request to create.php, it's also possible for us to make a get request. All we have to do is click on the URL up here in the browser bar at the top and hit return and now I've issued a get request to the same URL. In this case, our create.php handled the page just fine, we didn't get any errors back or anything like that, but that's not always necessarily the case. It might be that we want this page to be dedicated to form processing and not respond to simple requests that are not from a form.

Maybe we want to redirect do another page in that case. To do that, we need to be able to detect whether the form has been submitted or not. There are three main techniques that developers use to know whether a form has been submitted. The first is that you can test to see whether a key parameter is present in the form data and whether it has a value. The second is you can see whether there's a submit parameter that's been sent. I'll show you what that means in just a moment, and then the third is we can check to see whether the request method was a POST request.

The first of these is to check and see whether or not a key attribute has been submitted. For example, let's say we have a login form. We would expect that some value would be in the form data for username when the person goes to log in. So if we don't see username in the POST super global then we'll know that the form wasn't submitted. Because even if they left username blank, something should've been submitted for it. Another way people handle it is by adding a name attribute to their submit button. If we don't put any name attribute, our submit button doesn't submit any data for itself, it's just not included in the form data, but as soon as we add name equals something, now that value will be included in the form data.

When the form is submitted, there will be something present for that submit button. So we can check to see if it's there, we can check to see if that value is present. If it is, we'll know that the submit button had to have been clicked. But I think an even better way to do it, and the way that I'm going to recommend is to actually check and see whether the request method was a POST, and we can do that using the server super global and asking it for the request method, in all caps with the underscore between the two words. So if the request method is equal to POST, then we'll know that a form has been submitted.

If the request method is GET, then we'll know that it was a link or a URL. I like to take this and wrap it all up in a handy function, so here I have a function called request is post, and it just does that evaluation to see is the request method equal to post. And that's a nice handy convenient method we can put into any of our pages to find out whether the form has been submitted or not. Let's try adding this to our project. So I'm going to add this function into our private functions.php page, I'm just going to scroll down here after our redirect, I'm going to paste them in.

They're also available in the exercise files or you can pause the movie to copy this down, it's not a lot of text. But you can see that I'm actually providing two different functions, one for whether is a POST request the other is it a GET request, and it just returns the result of this evaluation. It's either going to return true or false, this is just a condition to check and see, is this equal to this, so we'll return that value back and then we can use it as a condition inside our page. So let's go to create.php. Now in order to have access to that function, we also need to come to new.php and just grab this require once line.

Let me make sure we have that, and then let's come back here, now we'll call initialize, that'll give us our functions, so now it has access to the function, and then we can put something in here for it, let's say if is post request, then and we're going to do all of this and I'll just indent it a bit, but if not, then what do we want it to do, let's have it redirect, redirect, and we wrote a helper method for that redirect to URL four and where do we want to send it, let's send them to staff subjects new.php.

Alright, so either if it's a POST request, display the parameters, if not, redirect them back to the form. Let's save this page and let's try it out. Let's come back over here and let's start by going backwards so that we have our form again, you can fill it out with any simple data you want, we're going to click create subject. And you see that I get my parameters, it displays them on the page. Now let's click up here at the top, and let's hit return, and look at that. It redirected me. It no longer processed my form, we were able to detect that this was not a POST request, and so it redirected instead.

Having these two functions in your standard library can be really useful, to check to see whether something is a POST request or a GET request and respond appropriately based on each one. 

4.4 Single Page Form Processing

In the last movie we learned how to detect when a form was being submitted to a page or whether the page was being loaded directly. We used it to redirect whenever it was not a post request. We can also use this same technique to do something I call single-page form processing. The idea is that we have a single page which contains both the form and the code to process that form. In other words, we'll have a form that submits to itself. There's nothing wrong with having the form and the form processing on two separate pages like we did with new and create, but having them on one page adds a few nice perks.

The first is just that all of the logic related to the form, how it's displayed and how it's processed, is all self contained in a single file. We haven't talked about form errors yet and when we do we'll realize that when there's a problem with the form we're going to want to redisplay the form back to the user so that they can fix it. We don't want that data to just simply disappear, we want to represent the form to the user pre-populated with their values so that they can fix the problems. So the idea here is that when we have a get request to the page it's going to simply show the form.

But when it's a post request we're going to have all the form processing take place at the top and if something goes wrong the form will be further down on the page. So we can simply redisplay the form again as needed with all of the values and error messages that it might need. Let me demonstrate. So we already have new and create as a form and a form processing page. Now for edit I want to make the edit be a single-page processor. So what I want to do is I want to take all of this code from create.php that we have and all of this is post request right here.

I'm going to take and just copy. I'm going to come back over here to edit.php, I'm going to take all of this code where we were testing things out, I'm just going to remove that and instead paste in my new code into the post request, then we're going to get those values and we're going to be able to display them. If not, right now we have something that says redirect, but we don't want to do that redirect, I'm going to just comment that out. So if it was not a post request then we want to just display the page. So process it if we've got it, if not display the page.

Let's try that out. In order to make it work we'll need to first put in a form action. Remember we didn't have that before. I'm going to cheat and just copy this link that we had up here down here and then I can just edit it. So it's already got all the URL for and instead it's going to go to edit.php. Remember though that edit.php needs to know what we're editing, so we need to pass in an ID as well. So I'm going to include an ID here. And for that ID I'm going to want to make sure that I escape it for HTML and URL encode it and I'm just going to use a value for ID.

Now that ID hasn't been set yet. We need to have a variable for the ID. So we need something that's going to read that in. So in every case, not just when it's a post request, we're always to want to have ID equals and get ID. Now if ID's not set, we know we could do something like this and have a default value, but if it's not set I want to do something more extreme than that. I want to say, if not is set get ID, then let's redirect.

Let's redirect to, and actually I'm going to copy this line down here just to save me some time. I'll remove that and let's come up here. Redirect to and I'm going to redirect back to index.php. So it'll go back to the list. So if I don't have an ID, don't show this page. ID is required or else we're going to redirect back to the index. Then I know I have an ID. If this is present I can assign it confidently. If it's a post request then I'll process it, if not then I'm going to show the page.

See how that works? Let's save it and let's try it all out. Go to our list and let's click on small business, click edit, ID is equal to three, you see we get our edit subject page. Let's try it, test, let's click edit subject. Look at that, it tested our form parameters. Now if I do a get request to it again, hit return up here, it doesn't do the form processing. Now let's take away our ID and let's just see that not having an ID is a show stopper, it takes us back to the subjects list page.

So we've now implemented single-page form processing. However, we don't really see the benefits of this yet. Let me drop down here though and show you that if in this value if instead of having nothing what if we put in echo, dollar sign, menu name. Now that will display whatever menu name has been submitted for us automatically. It'll appear right there. Now we also want to go up and make sure that we have a value for menu name set in all cases.

So I'm just going to come up here and before any of this page starts I'm going to make sure that menu name is initialized to just an empty string. And position, just so these don't blow up on us. And same thing with visible. Its not a bad idea whenever you have a form to just make sure that there are default values there. So if it's not a post request, then those will get handled. We could also put these here in this else statement, they could go there, but I like to go ahead and just put them at the top of the page. I'll remove that else statement 'cause we don't need it anymore.

Let's go back and let's try it out and see how it works. Click on edit. So now we're going to submit testing, testing. Edit subject and look at that. My form value stuck around. So if there had been a problem with it and that's why the editing didn't actually take place then you can see how we'd have the opportunity to edit it. We'll talk more about that in a future chapter when we talk about validations and errors. For now I just want you to see that we're setting ourselves up for taking advantage of that by having the form processing take place on the same page.

Our page can do double duty, it does one thing when it's a get request, it does a different thing when it's a post request. If you're still not convinced about the advantages that this offer, think for a moment about how you would do this with new.php and create.php. Once you process create.php how would you get this value to redisplay in the form? You can't just redirect back to the form because that's a new request when we do our redirect and those values would be lost. You can't really send those values in the URL string because there might be dozens of them.

You could potentially store these values and retrieve them, but that's really making something much harder that could be very easy. Single-page submission solves the problem for us in a simple way. 

4.5 Challenge -> Add Forms

It's time for another challenge assignment and like the challenge assignment that we had before, your goal is going to be to take the work that we did inside the subjects management area and to do the same thing inside the pages management area. Let's go over the points that you need to make sure you hit. The first is that you'll want to add a form under staff/pages/new.php. Replace any placeholder code you might have there and put in the correct page to display a form for creating a new page. Then you'll want to take that form and modify it so that you can also have an edit form so that you can edit an existing page.

You want to make sure that you add links to both pages from pages/index.php and remember that in the link to the edit.php page, editing will require having a page ID so that that's accessible and that eventually that page can go to the database and retrieve an existing page. Once you've got that, then work on the form processing. Use single-page form processing for both of the forms. When we were working with the subjects, we only did it for the edit page. The new page actually used two pages: new and create.

You're not going to use create.php. Do both of them as single-page form processing. So if a form was not submitted, you're just going to display the form, but if a form was submitted, then you'll display the form parameters at the top just like we did for subjects and then the form below that. Then inside the form, go ahead and display any submitted menu name that might have been sent in when the form was submitted. And then if you're up for a real challenge, as a bonus assignment you can display the submitted position and visible on the forms as well.

Right now we were only working with that text input. This requires you to work with select options and check boxes. So we'll need to write some PHP to check and see if the select option value and the checkbox value match the submitted value for those two attributes. Do your best. Remember that you can refer to my work on subjects if you need to, but try to write as much of it on your own as possible. That's the way that you learn. And then in the next movie I'll show you the results that I came up with. 

4.6 Solution -> Add Forms

I hope that you were successful with your challenge assignment. In this movie, I'm going to show you the solution that I came up with. First, let's look in a browser and then we'll take a look at the code. You can see, in the browser, I can click on Pages and I come up with my Pages area and I have a new link here now for Create New Page. And when I click on it, takes me to new.php and I get back a form to allow me to create a new page. So, I can add the Menu Name, I can type Position, and I can type Visible. So let's try just write Testing and I'll put in Visible true, and I'll click Create Page.

Now this submits to the same page, new.php, that's different than what we did throughout the rest of this chapter where we used create.php. We're using single-page submission here. Single-page form processing. So it's going to submit to itself, new.php and you can see that it lists the form parameters that came in. It says it received Testing, Position: 1, Visible: 1. And then it redisplays the page and you can see that it redisplayed the Menu Name here. And we have the Position and Visible is checked. If we were to uncheck it and click Create Page, we see Visible's now zero and it's not checked.

I added that detection in there. Let's go Back to List now and let's do the same thing for Edit. I'll click on leadership and you see, for here, we have Edit Page, we have our form, once again, we can type in Testing. Notice here that it also says id=3, it is passing along the ID of the page that it would look up in the database later on. And let's click Edit Page. You can see that it submits back to itself. It includes the ID, so that it can be found in the database again, using that URL parameter, but then we have the Form parameters here: Testing, Position: 1, Visible: 1, and those show up down here in the form as well.

Let's go look at the code. So, the first thing was that on that index.php page, I needed to add links so I just added a link right here that'll take me to staff/pages/new.php and I added a link down here that would take me to edit.php and also include the ID that I'm going to need to look up in the database. So, I've got the ID included as well. Then, in new.php, I have a form. So, the first thing I actually did was I added the form itself. So I have all the form down here, page title, the page header.

And then I've got my form with this action, then I've got all my form fields. Then, when that field submits, it's going to submit to itself, to new.php. And up here, I have code that says if it's a post request, then get those values and display them. Eventually, we would get those values and do something else with them. We would submit them to the database, for example. But for right now, we're just displaying them at the top of the page. If it's not a post request, then it just displays the form. So we only get that part when it's a post request but we go ahead and set default values for all of these just in case.

Because, further down the page, I'm going to echo back the menu name. Now, notice that I've also put an h in front of this as well. I need to make sure that I escape this for html. I did not do that in the last movie when we were talking about outputting this value; that was an oversight on my part. So we do need to escape these values for html, so I've got the h there. I also did the bonus assignment, which is that I checked to see if position was equal to one and if so, it's going to echo selected next to this option.

That'll mark this option as being selected. If the check box for visible is equal to one, then it's going to echo checked there. So that was the bonus assignment that I asked you to do. And then I did the same thing for edit.php. I've got my form, it just says edit page instead. It's going to submit to itself. It includes the ID with it. We did the same thing down here in the form, echoing back any existing menu name, checking to see whether these items were, in fact, the current values before outputting selected or checked. And then at the top, I've got my form processing.

If it's a post request, then display this information. And I've got some default settings here. I also had this additional bit of code at the top of the edit page to just make sure that we have an ID and, if not, it redirects to pages/index.php. Once I had done that and completed the assignment, I also went back to the subjects page and just made the changes here so that I made sure that this was escaped using h, and added in the parts for selected and for visible.

So that same code now applied to edit.php. On new.php, I did not change the code to make it single submission, you could do that if you wanted. And I did not bother putting in these additional values because if it's not single-page form submission, then there's really no way to redisplay these values on the page. That's the problem that we ran into. It's up to you whether you want to revise this page now, but we're going to come back to it a little later on. Hopefully, you were able to complete this challenge assignment on your own. If not, take a few minutes to figure out what you did wrong.

Look at my code, pause the movie if you need to to compare, and make sure that you get everything right before you meet me in the next chapter. 

5. MySQL Basics

5.1 MySQL Introduction 

We've learned to use PHP to build pages which link to other pages and to create web forms which can submit and process data. You can build a solid, dynamic website using only these tools, but for complex sites, you will reach the limits of what you can do with just PHP alone. Adding a database is the next step, and it offers many benefits. Databases provide a way to both read and write data. They allow you to store more information, and to keep that information organized, so that you can access it faster.

They also allow you to easily relate different types of data to each other. The database we'll be using is MySQL. You can use other databases with PHP, but MySQL is the best supported, and the most common choice. It's open source, and free, just like PHP. It's also very easy to use, and because it's popular, you'll find a lot of online support if you ever need help, and it provides a good introduction to many common database concepts. If you've never worked with a database before, chances are that you have worked with a spreadsheet like Microsoft Excel.

A database table is similar to a spreadsheet, in that it has columns and rows, which are populated with data. And, you can have multiple tables, the same way that many spreadsheets often let you have different worksheets or tabs, that you can switch between. But, databases are not like spreadsheets in some important ways. First of all, spreadsheets are optimized for adding numbers, that's what they do well, performing calculations on numbers. Databases are optimized for working with data, and most importantly, databases can traverse relationships between the tables.

They can move between the data, and spot relationships that are there. The other difference, is that spreadsheets you work with by using your mouse or your trackpad and the keyboard. You interact with them directly. For databases, we're going to be issuing commands to the database in order to get the database to do what we want it to do. Let's review some common database terminology. A database is a set of tables, and we can have several databases running in MySQL at the same time. Each database will contain its own set of tables, and different tables do not interact.

So, we'll create one database for the sample web application that we'll be building, and in general, you're going to have this relationship, one database equals one application. MySQL will allow you to control user access table by table, but with web applications, most of the time, we'll have one database user, being the web app, and it will have permission to use any of the tables that are in that database. Our database is going to be made up of tables, and our tables are going to made up of rows and columns. As we discussed, it's a lot like a spreadsheet.

Each table will contain one type of information, a noun. And, since there will be many records of that type in the table, it's usually a plural noun. For example, products, customers, orders, maybe countries, students, or transactions. They don't have to be concrete nouns, they can represent more abstract ideas, like categories, favorites, or settings. Relational databases get their power from being able to make relationships between the tables. A single customer record in the customers table has a relationship to the customer's past orders, which are stored in the orders table.

Each order in the orders table has a relationship to the products that are in that order, and those products are stored in the products table. A table has a defined structure for storing its data. A column is defined for storing each data type. For example, first_name, last_name, email and password. These are similar to the columns on a spreadsheet. Each column has a specific type. A column for holding strings like first_name can only hold strings. A column for holding numbers or integers can only hold integers. These keeps the data organized, but it also helps the database to allocate an appropriate amount of storage space for it, and to locate that data faster.

A database row can also be called a record. It's the set of data that's in each column. So, if the columns are first_name, last_name, email, password, then a single row might contain Bob, Smith, bob@email.com, and then his password, secret. Again, this is similar to a spreadsheet row. A field is simply the intersection of a row and a column. And in practice, the terms field and column are used rather interchangeably. There are two concepts which are essential to making relational databases work. First, we have a primary key.

Each record has a primary key which serves as a unique identifier for that record. For example, you might have a customers table containing 500 customers. By giving them all unique identifiers, numbered one through 500, I can request the record for customer 207, and the database knows right away where to look to retrieve that data. A foreign key is a column which references another table. It's the foundation of relational databases. For example, if we have a customer with a primary key of 207, and that customer has five orders, then in the orders table, I would expect that there would be five records with a customer ID of 207.

The information in the foreign key column is the way that I know that those order records belong to that customer. We'll come back to this concept a little later on in more detail. And then, we've got an index. An index is a data structure on the table that increases its lookup speed. It's a lot like the index that's at the back of the book. You turn to the back of the book, you look in the index, and you look for what you want to find, and it tells you immediately what page to turn to. You don't have to search through the whole book, you can quickly go to exactly what you're looking for. Primary keys and foreign keys are the most common indexes that we use, because they allow us to look up those records by their identifiers very quickly, but you can also have other indexes on data which is used frequently, in order to look up records.

There's one other term that's helpful to know when working with databases, and that's CRUD. It's an acronym for create, read, update, and delete. These are the four primary operations that we perform on databases. We create new records, we read existing records, we update those existing records, and we can delete records. We'll be performing these four operations over and over again on our database. So, we'll often just refer to it as CRUD as a shorthand. 

5.2 Create a Database

In this movie, we're going to log into MySQL and create our first database. In order to interact with MySQL, we're going to do that from our command line program. If you're on Windows, that program is going to be command prompt, on Mac it's going to be the Terminal. So here I am inside my Terminal application and the first thing we want to do, is make sure that we have MySQL installed. So if you don't have it installed already, you'll want to do that. Let's just check and see here, mysql version. You see I have Version 5.7 installed. It doesn't matter if your version is slightly different from mine, MySQL in general works pretty much the same in all the versions.

Then we want to actually try to log in, to make sure that it's running. We try mysql -you and I have a root user created. Every MySQL installation has a root user by default. I'm going to hit return, and you'll see that it doesn't open up for me, and that's because I didn't tell it that I had a password. By default, a lot of times MySQL doesn't have a root password, but it's a good idea to make sure that you do have one. Secure that root user, because the root user is your most powerful MySQL user. It's the user that has the ability to do anything inside MySQL.

So I'm going to also put the -p option after it, and that's going to allow me to provide a password. So now it's going to ask for my password, and there it is. Now I'm logged into MySQL. So I know I have MySQL installed and it's running. So now we're ready to work inside MySQL. What are the commands that we want to issue? There are four main commands we need to know about creating databases. The first is show databases, and that just simply shows us a list of the databases that are already there.

Notice that it has a semicolon at the end, all commands in MySQL should end in a semicolon. That's how MySQL knows that the command is done. The capitalization doesn't matter, but it's a best practice and it makes your code more readable, so I tend to capitalize things. The second command is to create the database. All we have to do is tell it the name of the database we want. Create database and then the name of the database. Capitalization does matter for the database name and there should be no spaces in it, but you can use underscores. Then, when ready to actually use the database, we can use database name.

If we want to drop the database, or get rid of it, you use drop database and the database name. Use database name is really only if you didn't specify the database when you logged in, or if you want to switch between databases. It's not something we're going to use very often, but if you have multiple databases, it allows you to move around between them, so that you're currently in an active database. So to begin with, let's just do show databases. You can see the databases that are there by default. These are the default MySQL databases. They're not for your use, they're there for MySQL to use, so don't mess with any of these basic ones that are there.

But we want to create our own. So create database and then let's call it globe_bank; That's it, that's all it took to create the database. Now I'm going to hit the up arrow. It'll allow me to go back to show databases again, and now you can see that my database is listed there. As I said, we can use the database, and that will switch us into it, so it's our current active database that we're working with, and we can also drop the database. Drop database globe_bank; and just like that, our database is gone.

Now hopefully we didn't have lots of data in there, because as soon as we say drop database, you can see, everything that was in that database just instantly disappears. It's a very powerful command. So we want to be careful about that. I'm going to hit the up arrow a couple of times, so that I can create my database again, and now show databases, you can see it's going to list it again. So now I have my database there. Now when we logged into MySQL right now, we did it as the root user. That's the most powerful user with lots of privileges to perform actions inside MySQL, from creating tables to dropping them.

We could log in from our web application as the root use as well, but I think that's a really bad habit. It's much better to create a new MySQL user and assign it a password, and then grant access to our database to that user. It limits the scope of access, to just that single database. Now, we don't have access to everything, we only have access to the database we've granted privileges on. It's better security and there's no excuse not to do it, because it's easy to set up. All we have to do is type a command like this, grant all privileges on, and then the name of the database and then a period and then an asterisk.

The asterisk says we're granting privileges to all tables on that database, and that's a best practice. Then there's a space after the asterisk, that you can't see because I dropped to a new line, and then it says to, and then we want to create a username. This is going to be a new user that we're creating. It can be any name you want, inside those single quotes and then @ and then the IP address, or the location that that user would be allowed to log in from. We're going to use localhost. That means that only from this computer can that user log in.

They can't log in from some other foreign country, some other IP address and get into this database. Only our web app, which is locally hosted, can access it. That's another good security practice. Then there's a space at the end of that, and then the next line is, identified by password. If this user already exists in the database, we can leave out that last bit, but if it's a brand new user, this gives us the chance to say what the password is that goes with that username. We can also take a look at what grants have already been given to that user, using show grants for that username.

All right, so let's try adding a new user and granting privileges on our database to them. So again, my command is going to be grant all privileges on, and then the name of the database, globe_bank. and then the asterisk, because it's all tables, to, I'm going to call my user webuser. You can call it anything you want, and then @localhost, and then a space, identified by, and then whatever password you want to use.

I'm going to use secretpassword, just to have a convenient one, but that's not a great password. You should hopefully pick a better password. So pick a good password that you can use for your user, and then let's hit return. Now we have a new user created called webuser, and that user can use their username and password to access our globe_bank database. 

5.3 Create a Database Table

In the last movie, we created a database that we could use. And now we're ready to add our first table to that database. The way that you create a table in MySQL is using this syntax. CREATE TABLE, and then the table name you want to create, and then inside parentheses, you're going to provide a set of definitions for what the columns in that table are going to look like. So you have column_name1, and then its definition, a comma, and then column_name2, and its definition, and so on. And at the end, there's the opportunity to provide a few extra options for how you're going to create that table.

We'll look at this in more detail. Once you've created a table, then you can show the tables, just like we showed databases. We can call SHOW TABLES to know what the tables are. We can show the columns that are from that table, to see what its structure looks like, and we can drop the table. Just like we drop the database, you can drop a whole table, which of course erases all its data at the same time. So, what are we going to create for our database table? That's always a good starting point, is to think about what the database ought to look like. We're going to create a table for subjects.

It's going to be a place to hold all of the subjects that we need in our content management system. We know that it's going to need a primary key. That's the id. As a general rule, every single database table needs a primary key, an id, all lowercase, is a good one to use. Then, we should think about what it's going to contain. We've got the menu name, menu_name, and we know that's going to contain a string, right, it's text. Then we've got the position. The position will be an integer, one, two, three, four, five, so we're going to store that, and then we're also going to store whether or not this subject is visible or not.

The idea is that we have the ability to suppress some subjects so they don't show up to the public. There it can be staged and get everything set up in the admin area, and then we can take the invisible only when we want to. That's going to be a boolean, meaning that it's going to be true or false. So the way that we would create this in MySQL would be like this. CREATE TABLE subjects, and then in parentheses, you can see I have id, menu_name, position, and visible. And next to each one of those, I have the definition for what that field ought to look like.

The first one is very standard. Whenever we have a primary key, this is probably the way you want to do it. We're saying, the primary key is going to be an integer, and it can be a large integer, it can have 11 different characters in the number. That's how big it can be, and it's going to be NOT NULL, meaning it can never be empty, it always has to have a value. And we're going to ask MySQL to automatically AUTO_INCREMENT that value for us. That'll ensure that it always stays unique. So if we add one subject, it'll be subject number one, then we add a second one, MySQL will make sure that that second one automatically becomes id number two.

It'll do it for us, we don't have to know what the next one is, we just say hey, add a new subject, and it'll say okay, I already have a subject number one, so this must be subject number two. It's a nice feature. And then you can see that menu_name, which was going to be a string, has a column type of VARCHAR. That's short for variable length characters, and it can have up to 255 characters in there. If we needed something longer, then MySQL has a type called text that we could use if we needed a large block of text.

But 255 characters is good for most short strings, like the menu name. For position, I've told that it's going to be an integer, so it's an INT again, that's short for integer, but I've told it that it only needs to reserve three integer places for this. That is, it's a number that's going to be less than 999. For the position of this content, that should be more than enough. But it's not a problem if you want to make it a larger number too. And then for visible, which is a boolean, the convention is to use TINYINT. It's a tiny integer, and we just use one.

We're basically saying there's a small integer, and that's because what we're going to store there is not true or false, but zero or one, and TINYINT will allow us to do that. And then you can see at the end, I've also told as a special option that the primary key of this table ought to be id. This can be a lot when you're first starting out, but remember you can always come back and refer to it, and then the MySQL documentation can also help you out. Let's add this table definition to our project. So you can see that I'm already logged into MySQL, I've called SHOW DATABASES, which shows me the databases, and you can see I created that globe_bank database in the last movie.

You also want to make sure that you use USE and then globe_bank. That will make sure that we're using that database, that it's our active database. It's also possible when you first log in to provide that as an option, and go directly in to this database, but I didn't do that, so in order to make sure that I'm on the right database, I want to use that. And that's because when I call SHOW TABLES, I don't specify the database, I just said SHOW TABLES. So how does it know which database? Well it uses the database that I'm on right now, that's where it gets its SHOW TABLES from.

All right, so now let's create our subjects table. I'm going to paste in the SQL for this. You can also find this in the Exercise Files, if you want to copy and paste it from there, or you can take the time to type it up, because it's a good way to actually learn it, by typing it all up and forcing yourself to actually go through the motions of typing each of those characters. So if you want to pause the movie, you can copy it down, but you can see that I created the table, I created all the different columns that I would need, and at the end it says Query OK, lets me know that everything worked out all right. Now when I call SHOW TABLES, you'll see that it says that I have my subjects table.

And if I say SHOW COLUMNS FROM subjects, you'll see that it comes back and tells me what the subjects table looks like, it gives me a definition, and it tells me the different fields that it has, and the type associated with each one of those. Now I could DROP TABLE subjects, I'll just do that, you don't have to do this along with me, but I'm going to show you that I can drop it, and now it's gone, now the up arrow, it's just gone. And all the data that was in it is gone as well.

I'm going to recreate it because I obviously want that table, so now when I say SHOW TABLES, it's there again. So that's it, that's how we create new tables in MySQL so that we can work with them. And because we granted access to all the tables to our web application user, we have access to any table that we create on this database, automatically. 

5.4 CRUD in MySQL


At the beginning of this chapter, I introduced you to this acronym: CRUD, C-R-U-D. In this movie, we're going to learn how you implement CRUD in MySQL. You recall that CRUD is an acronym for the four most basic operations that we perform on databases: Create, Read, Update, and Delete, and these are the four things that we're going to do over and over and over again with MySQL, so we need to learn the syntax that we can use to perform each one of these and there's a specific syntax and it's different for each one.

So let's first start by looking at read, this is the one we're going be performing the most often. The idea is that we're reading information back from the database, we do that far more often than we create, update, or delete data, we're constantly reading data back. The way that we read data in MySQL is with the select command. So select and then we say what we want to bring back from the database table. I've got an asterisk because I want to bring back all columns, so it's a while card saying, bring back all the data that you've got, every bit of information about this record, I want to bring back.

You can also specify common unlimited list if you only wanted certain columns to come back from the database, and then, in the next line, you see I've got from table or I tell it what table it out of be retrieving this information from. I can specify a where clause if I want, I don't have to, but I can say where ID equals seven, if I want a specific record, if I want record number seven or where last name equals Scogland or where state equals Pennsylvania, anything like that you can bring back as a conditional clause and you can join those together too with and statements, where one thing is true and something else is true, where clauses can be very complex and then we've got order by, and again this is optional but it says how we want to order the records that are returned to us.

There are other options available to you that will allow to pick only certain records from the set maybe to limit it to a certain amount or to skip over certain records, but we're just going to focus on the basics for now. This is a basic SQL select statement. Next, we have the SQL insert statement, which is used to create records and for that, we use insert and then into what table we want. Let me provide a list of columns, the order of the columns can be anything that we want but then in the next portion in the parenthesis after values, you'll see that we're specifying the values that out of go in each of those columns, and the order needs to match what was in the order before.

So we're basically saying, take each one of these values and put 'em in the list of columns that I already gave you. And then there's SQL update. We update a table, we set values equal to each of the different attributes, where something is true. We usually don't want to do it to the whole table, you certainly can, you can update the entire table to have a certain value, but usually we want to update just a subset of the records, it can be one single record like it is in this case, where its ID equals one, or we could say, update all records where the state is equal to TX and convert that to be Texas, so we want to change TX to be Texas, all records would instantly be changed.

So, update table, set each one of the columns equal to the new value and then where ID equals one. This syntax is a little different than the way we created records. And then we've got SQL delete and this just allows us to delete from a table where something is true and again we could delete all records, we could say delete all records where the state is Alaska and they would all just instantly disappear, but more often we want to delete one specific record, in this case we're deleting the record that has ID number one.

Now I certainly don't expect that you're going to remember all four of these right from the start, as a beginner, you're probably going to have to look them up often. My hope is that this movie can serve as a reference if you forget. The MySQL documentation also has the same commands and gives you details on the many other options that you can use with them. In the next movie, we going to get some hands on experience using them. 


5.5 Populate a MySQL Table




5.6 Relational Database Tables




5.7 Challenge -> Pages Table




5.8 Solution -> Pages Table





